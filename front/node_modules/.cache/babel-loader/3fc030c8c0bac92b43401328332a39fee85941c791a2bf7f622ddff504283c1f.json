{"ast":null,"code":"import { CDATA, SELF_CLOSING_TAGS, escapeHTML, hArgumentParser, hFactory, html, htmlVDOM, markup, unescapeHTML } from \"./chunk-B6CCJBSJ.js\";\n\n// src/vcss.ts\nimport { parse } from \"css-what\";\nvar cache = {};\nfunction parseSelector(selector) {\n  let ast = cache[selector];\n  if (ast == null) {\n    ast = parse(selector);\n    cache[selector] = ast;\n  }\n  return ast;\n}\nfunction matchSelector(selector, element) {\n  let {\n    debug = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  for (let rules of parseSelector(selector)) {\n    if (debug) {\n      console.log(\"Selector:\", selector);\n      console.log(\"Rules:\", rules);\n      console.log(\"Element:\", element);\n    }\n    const handleRules = (element2, rules2) => {\n      var _a, _b, _c;\n      let success = false;\n      for (let part of rules2) {\n        const {\n          type,\n          name,\n          action,\n          value,\n          ignoreCase = true,\n          data\n        } = part;\n        if (type === \"attribute\") {\n          if (action === \"equals\") {\n            success = element2.getAttribute(name) === value;\n            if (debug) console.log(\"Attribute equals\", success);\n          } else if (action === \"start\") {\n            success = !!((_a = element2.getAttribute(name)) == null ? void 0 : _a.startsWith(value));\n            if (debug) console.log(\"Attribute start\", success);\n          } else if (action === \"end\") {\n            success = !!((_b = element2.getAttribute(name)) == null ? void 0 : _b.endsWith(value));\n            if (debug) console.log(\"Attribute start\", success);\n          } else if (action === \"element\") {\n            if (name === \"class\") {\n              success = element2.classList.contains(value);\n              if (debug) console.log(\"Attribute class\", success);\n            } else {\n              success = !!((_c = element2.getAttribute(name)) == null ? void 0 : _c.includes(value));\n              if (debug) console.log(\"Attribute element\", success);\n            }\n          } else if (action === \"exists\") {\n            success = element2.hasAttribute(name);\n            if (debug) console.log(\"Attribute exists\", success);\n          } else {\n            console.warn(\"Unknown CSS selector action\", action);\n          }\n        } else if (type === \"tag\") {\n          success = element2.tagName === name.toUpperCase();\n          if (debug) console.log(\"Is tag\", success);\n        } else if (type === \"universal\") {\n          success = true;\n          if (debug) console.log(\"Is universal\", success);\n        } else if (type === \"pseudo\") {\n          if (name === \"not\") {\n            let ok = true;\n            data.forEach(rules3 => {\n              if (!handleRules(element2, rules3)) {\n                ok = false;\n              }\n            });\n            success = !ok;\n          }\n          if (debug) console.log(\"Is :not\", success);\n        } else {\n          console.warn(\"Unknown CSS selector type\", type, selector, rules2);\n        }\n        if (!success) break;\n      }\n      return success;\n    };\n    if (handleRules(element, rules)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/vdom.ts\nvar inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nvar B = {\n  fontWeight: \"bold\"\n};\nvar I = {\n  fontStyle: \"italic\"\n};\nvar M = {\n  backgroundColor: \"rgb(255, 250, 165)\"\n};\nvar U = {\n  textDecorations: \"underline\"\n};\nvar S = {\n  textDecorations: \"line-through\"\n};\nvar DEFAULTS = {\n  b: B,\n  strong: B,\n  em: I,\n  i: I,\n  mark: M,\n  u: U,\n  a: U,\n  s: S,\n  del: S,\n  ins: M,\n  strike: S\n};\nvar toCamelCase = s => s.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase());\nvar _VNode = class {\n  constructor() {\n    this.append = this.appendChild;\n    this._parentNode = null;\n    this._childNodes = [];\n  }\n  get nodeType() {\n    console.error(\"Subclasses should define nodeType!\");\n    return 0;\n  }\n  get nodeName() {\n    console.error(\"Subclasses should define nodeName!\");\n    return \"\";\n  }\n  get nodeValue() {\n    return null;\n  }\n  cloneNode() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let node = new this.constructor();\n    if (deep) {\n      node._childNodes = this._childNodes.map(c => c.cloneNode(true));\n      node._fixChildNodesParent();\n    }\n    return node;\n  }\n  _fixChildNodesParent() {\n    this._childNodes.forEach(node => node._parentNode = this);\n  }\n  insertBefore(newNode, node) {\n    if (newNode !== node) {\n      let index = node ? this._childNodes.indexOf(node) : 0;\n      if (index < 0) index = 0;\n      this._childNodes.splice(index, 0, newNode);\n      this._fixChildNodesParent();\n    }\n  }\n  appendChild(node) {\n    if (node == null) return;\n    if (node === this) {\n      console.warn(\"Cannot appendChild to self\");\n      return;\n    }\n    if (node instanceof VDocument) {\n      console.warn(\"No defined how to append a document to a node!\", node);\n    }\n    if (node instanceof VDocumentFragment) {\n      for (let c of [...node._childNodes]) {\n        this.appendChild(c);\n      }\n    } else if (Array.isArray(node)) {\n      for (let c of [...node]) {\n        this.appendChild(c);\n      }\n    } else if (node instanceof _VNode) {\n      node.remove();\n      this._childNodes.push(node);\n    } else {\n      try {\n        const text = typeof node === \"string\" ? node : JSON.stringify(node, null, 2);\n        this._childNodes.push(new VTextNode(text));\n      } catch (err) {\n        console.error(\"The data \".concat(node, \" to be added to \").concat(this.render(), \" is problematic: \").concat(err));\n      }\n    }\n    this._fixChildNodesParent();\n  }\n  removeChild(node) {\n    let i = this._childNodes.indexOf(node);\n    if (i >= 0) {\n      node._parentNode = null;\n      this._childNodes.splice(i, 1);\n      this._fixChildNodesParent();\n    }\n  }\n  remove() {\n    var _a;\n    (_a = this == null ? void 0 : this.parentNode) == null ? void 0 : _a.removeChild(this);\n    return this;\n  }\n  replaceChildren() {\n    for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n    this._childNodes = nodes.map(n => typeof n === \"string\" ? new VTextNode(n) : n.remove());\n    this._fixChildNodesParent();\n  }\n  replaceWith() {\n    for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      nodes[_key2] = arguments[_key2];\n    }\n    let p = this._parentNode;\n    if (p) {\n      let index = this._indexInParent();\n      if (index >= 0) {\n        nodes = nodes.map(n => typeof n === \"string\" ? new VTextNode(n) : n.remove());\n        p._childNodes.splice(index, 1, ...nodes);\n        this._parentNode = null;\n        p._fixChildNodesParent();\n      }\n    }\n  }\n  _indexInParent() {\n    if (this._parentNode) {\n      return this._parentNode.childNodes.indexOf(this);\n    }\n    return -1;\n  }\n  get parentNode() {\n    return this._parentNode;\n  }\n  get childNodes() {\n    return this._childNodes || [];\n  }\n  get children() {\n    return this._childNodes || [];\n  }\n  get firstChild() {\n    return this._childNodes[0];\n  }\n  get lastChild() {\n    return this._childNodes[this._childNodes.length - 1];\n  }\n  get nextSibling() {\n    let i = this._indexInParent();\n    if (i != null) {\n      return this.parentNode.childNodes[i + 1] || null;\n    }\n    return null;\n  }\n  get previousSibling() {\n    let i = this._indexInParent();\n    if (i > 0) {\n      return this.parentNode.childNodes[i - 1] || null;\n    }\n    return null;\n  }\n  flatten() {\n    let elements = [];\n    if (this instanceof VElement) {\n      elements.push(this);\n    }\n    for (let child of this._childNodes) {\n      elements.push(...child.flatten());\n    }\n    return elements;\n  }\n  flattenNodes() {\n    let nodes = [];\n    nodes.push(this);\n    for (let child of this._childNodes) {\n      nodes.push(...child.flattenNodes());\n    }\n    return nodes;\n  }\n  render() {\n    return \"\";\n  }\n  get textContent() {\n    return this._childNodes.map(c => c.textContent).join(\"\");\n  }\n  set textContent(text) {\n    this._childNodes = [];\n    if (text) {\n      this.appendChild(new VTextNode(text.toString()));\n    }\n  }\n  contains(otherNode) {\n    if (otherNode === this) return true;\n    return this._childNodes.some(n => n.contains(otherNode));\n  }\n  get ownerDocument() {\n    var _a;\n    if (this.nodeType === _VNode.DOCUMENT_NODE || this.nodeType === _VNode.DOCUMENT_FRAGMENT_NODE) {\n      return this;\n    }\n    return (_a = this == null ? void 0 : this._parentNode) == null ? void 0 : _a.ownerDocument;\n  }\n  toString() {\n    return \"\".concat(this.nodeName);\n  }\n  [inspect]() {\n    return \"\".concat(this.constructor.name, \" \\\"\").concat(this.render(), \"\\\"\");\n  }\n};\nvar VNode = _VNode;\nVNode.ELEMENT_NODE = 1;\nVNode.TEXT_NODE = 3;\nVNode.CDATA_SECTION_NODE = 4;\nVNode.PROCESSING_INSTRUCTION_NODE = 7;\nVNode.COMMENT_NODE = 8;\nVNode.DOCUMENT_NODE = 9;\nVNode.DOCUMENT_TYPE_NODE = 10;\nVNode.DOCUMENT_FRAGMENT_NODE = 11;\nvar VTextNode = class extends VNode {\n  constructor() {\n    let text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    super();\n    this._text = text;\n  }\n  get nodeType() {\n    return VNode.TEXT_NODE;\n  }\n  get nodeName() {\n    return \"#text\";\n  }\n  get nodeValue() {\n    return this._text || \"\";\n  }\n  get textContent() {\n    return this.nodeValue;\n  }\n  render() {\n    var _a;\n    const parentTagName = (_a = this.parentNode) == null ? void 0 : _a.tagName;\n    if (parentTagName === \"SCRIPT\" || parentTagName === \"STYLE\") {\n      return this._text;\n    }\n    return escapeHTML(this._text);\n  }\n  cloneNode() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let node = super.cloneNode(deep);\n    node._text = this._text;\n    return node;\n  }\n};\nvar VNodeQuery = class extends VNode {\n  getElementById(name) {\n    return this.flatten().find(e => e._attributes[\"id\"] === name);\n  }\n  getElementsByClassName(name) {\n    return this.flatten().filter(e => e.classList.contains(name));\n  }\n  matches(selector) {\n    return matchSelector(selector, this);\n  }\n  querySelectorAll(selector) {\n    return this.flatten().filter(e => e.matches(selector));\n  }\n  querySelector(selector) {\n    return this.flatten().find(e => e.matches(selector));\n  }\n  parent(selector) {\n    var _a;\n    if (this.matches(selector)) {\n      return this;\n    }\n    if (this.parentNode == null) {\n      return null;\n    }\n    return (_a = this.parentNode) == null ? void 0 : _a.parent(selector);\n  }\n  handle(selector, handler) {\n    let i = 0;\n    for (let el of this.querySelectorAll(selector)) {\n      handler(el, i++);\n    }\n  }\n};\nvar VElement = class extends VNodeQuery {\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"div\";\n    let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this._originalTagName = name;\n    this._nodeName = (name || \"\").toUpperCase();\n    this._attributes = attrs || {};\n    this._styles = null;\n  }\n  get nodeType() {\n    return VNode.ELEMENT_NODE;\n  }\n  get nodeName() {\n    return this._nodeName;\n  }\n  cloneNode() {\n    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let node = super.cloneNode(deep);\n    node._originalTagName = this._originalTagName;\n    node._nodeName = this._nodeName;\n    node._attributes = Object.assign({}, this._attributes);\n    return node;\n  }\n  get attributes() {\n    return this._attributes;\n  }\n  _findAttributeName(name) {\n    const search = name.toLowerCase();\n    return Object.keys(this._attributes).find(name2 => search === name2.toLowerCase()) || null;\n  }\n  setAttribute(name, value) {\n    this.removeAttribute(name);\n    this._attributes[name] = value;\n    this._styles = null;\n  }\n  getAttribute(name) {\n    const originalName = this._findAttributeName(name);\n    return originalName ? this._attributes[originalName] : null;\n  }\n  removeAttribute(name) {\n    const originalName = this._findAttributeName(String(name));\n    if (originalName) {\n      delete this._attributes[name];\n    }\n  }\n  hasAttribute(name) {\n    const originalName = this._findAttributeName(name);\n    return originalName ? this._attributes[originalName] != null : false;\n  }\n  get style() {\n    if (this._styles == null) {\n      let styles = Object.assign({}, DEFAULTS[this.tagName.toLowerCase()] || {});\n      let styleString = this.getAttribute(\"style\");\n      if (styleString) {\n        let m;\n        let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g;\n        while (m = re.exec(styleString)) {\n          let name = m[1];\n          let value = m[2].trim();\n          styles[name] = value;\n          styles[toCamelCase(name)] = value;\n        }\n      }\n      this._styles = styles;\n    }\n    return this._styles;\n  }\n  get tagName() {\n    return this._nodeName;\n  }\n  get id() {\n    return this._attributes.id || null;\n  }\n  set id(value) {\n    if (value == null) delete this._attributes.id;else this._attributes.id = value;\n  }\n  get src() {\n    return this._attributes.src;\n  }\n  set src(value) {\n    if (value == null) delete this._attributes.src;else this._attributes.src = value;\n  }\n  getElementsByTagName(name) {\n    name = name.toUpperCase();\n    let elements = this.flatten();\n    if (name !== \"*\") {\n      return elements.filter(e => e.tagName === name);\n    }\n    return elements;\n  }\n  setInnerHTML(html2) {\n    throw \"setInnerHTML is not implemented; see vdomparser for an example\";\n  }\n  get innerHTML() {\n    return this._childNodes.map(c => c.render(html)).join(\"\");\n  }\n  set innerHTML(html2) {\n    this.setInnerHTML(html2);\n  }\n  get outerHTML() {\n    return this.render(htmlVDOM);\n  }\n  get className() {\n    return this._attributes[\"class\"] || \"\";\n  }\n  set className(name) {\n    if (Array.isArray(name)) {\n      name = name.filter(n => !!n).join(\" \");\n    } else if (typeof name === \"object\") {\n      name = Object.entries(name).filter(_ref => {\n        let [k, v] = _ref;\n        return !!v;\n      }).map(_ref2 => {\n        let [k, v] = _ref2;\n        return k;\n      }).join(\" \");\n    }\n    this._attributes[\"class\"] = name;\n  }\n  get classList() {\n    let self = this;\n    let classNames = (this.className || \"\").trim().split(/\\s+/g) || [];\n    return {\n      contains(s) {\n        return classNames.includes(s);\n      },\n      add(s) {\n        if (!classNames.includes(s)) {\n          classNames.push(s);\n          self.className = classNames;\n        }\n      },\n      remove(s) {\n        let index = classNames.indexOf(s);\n        if (index >= 0) {\n          classNames.splice(index, 1);\n          self.className = classNames;\n        }\n      }\n    };\n  }\n  render() {\n    let h2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : htmlVDOM;\n    return h2(this._originalTagName || this.tagName, this.attributes, this._childNodes.map(c => c.render(h2)).join(\"\"));\n  }\n};\nvar VDocType = class extends VNode {\n  get nodeName() {\n    return super.nodeName;\n  }\n  get nodeValue() {\n    return super.nodeValue;\n  }\n  get nodeType() {\n    return VDocType.DOCUMENT_TYPE_NODE;\n  }\n  render() {\n    return \"<!DOCTYPE html>\";\n  }\n};\nvar VDocumentFragment = class extends VNodeQuery {\n  get nodeType() {\n    return VNode.DOCUMENT_FRAGMENT_NODE;\n  }\n  get nodeName() {\n    return \"#document-fragment\";\n  }\n  render() {\n    let h2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : htmlVDOM;\n    return this._childNodes.map(c => c.render(h2) || []).join(\"\");\n  }\n  get innerHTML() {\n    return this._childNodes.map(c => c.render(html)).join(\"\");\n  }\n  createElement(name) {\n    let attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new VElement(name, attrs);\n  }\n  createDocumentFragment() {\n    return new VDocumentFragment();\n  }\n  createTextNode(text) {\n    return new VTextNode(text);\n  }\n};\nvar VDocument = class extends VDocumentFragment {\n  get nodeType() {\n    return VNode.DOCUMENT_NODE;\n  }\n  get nodeName() {\n    return \"#document\";\n  }\n  get documentElement() {\n    return this.firstChild;\n  }\n  render() {\n    let h2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : htmlVDOM;\n    let content = super.render(h2);\n    if (this.docType) {\n      content = this.docType.render() + content;\n    }\n    return content;\n  }\n};\nvar VHTMLDocument = class extends VDocument {\n  constructor() {\n    let empty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    super();\n    this.docType = new VDocType();\n    if (!empty) {\n      let html2 = new VElement(\"html\");\n      let body = new VElement(\"body\");\n      let head = new VElement(\"head\");\n      let title = new VElement(\"title\");\n      html2.appendChild(head);\n      head.appendChild(title);\n      html2.appendChild(body);\n      this.appendChild(html2);\n    }\n  }\n  get body() {\n    let body = this.querySelector(\"body\");\n    if (!body) {\n      let html2 = this.querySelector(\"html\");\n      if (!html2) {\n        html2 = new VElement(\"html\");\n        this.appendChild(html2);\n      }\n      body = new VElement(\"body\");\n      html2.appendChild(html2);\n    }\n    return body;\n  }\n  get title() {\n    var _a;\n    return ((_a = this.querySelector(\"title\")) == null ? void 0 : _a.textContent) || \"\";\n  }\n  set title(title) {\n    const titleElement = this.querySelector(\"title\");\n    if (titleElement) titleElement.textContent = title;\n  }\n  get head() {\n    let head = this.querySelector(\"head\");\n    if (!head) {\n      let html2 = this.querySelector(\"html\");\n      if (!html2) {\n        html2 = new VElement(\"html\");\n        this.appendChild(html2);\n      }\n      head = new VElement(\"head\");\n      html2.insertBefore(html2);\n    }\n    return head;\n  }\n};\nfunction createDocument() {\n  return new VDocument();\n}\nfunction createHTMLDocument() {\n  return new VHTMLDocument();\n}\nvar document = createDocument();\nvar h = hFactory({\n  document\n});\n\n// src/utils.ts\nfunction removeBodyContainer(body) {\n  let ehead = body.querySelector(\"head\");\n  let ebody = body.querySelector(\"body\");\n  if (ebody || ehead) {\n    let body2 = new VDocumentFragment();\n    ehead && body2.appendChild(ehead.childNodes);\n    ebody && body2.appendChild(ebody.children);\n    return body2;\n  }\n  return body;\n}\n\n// src/htmlparser.ts\nvar attrRe = /([^=\\s]+)(\\s*=\\s*((\"([^\"]*)\")|('([^']*)')|[^>\\s]+))?/gm;\nvar endTagRe = /^<\\/([^>\\s]+)[^>]*>/m;\nvar startTagRe = /^<([^>\\s\\/]+)((\\s+[^=>\\s]+(\\s*=\\s*((\"[^\"]*\")|('[^']*')|[^>\\s]+))?)*)\\s*\\/?\\s*>/m;\nvar selfCloseTagRe = /\\s*\\/\\s*>\\s*$/m;\nvar HtmlParser = class {\n  constructor(options) {\n    this.attrRe = attrRe;\n    this.endTagRe = endTagRe;\n    this.startTagRe = startTagRe;\n    this.defaults = {\n      ignoreWhitespaceText: false\n    };\n    options = options || {};\n    if (options.scanner) {\n      this.scanner = options.scanner;\n      options.scanner = null;\n    }\n    this.options = Object.assign({}, this.defaults, options);\n  }\n  parse(html2) {\n    let treatAsChars = false;\n    let index, match, characters;\n    while (html2.length) {\n      if (html2.substring(0, 4) === \"<!--\") {\n        index = html2.indexOf(\"-->\");\n        if (index !== -1) {\n          this.scanner.comment(html2.substring(4, index));\n          html2 = html2.substring(index + 3);\n          treatAsChars = false;\n        } else {\n          treatAsChars = true;\n        }\n      } else if (html2.substring(0, 2) === \"</\") {\n        match = this.endTagRe.exec(html2);\n        if (match) {\n          html2 = RegExp.rightContext;\n          treatAsChars = false;\n          this.parseEndTag(RegExp.lastMatch, match[1]);\n        } else {\n          treatAsChars = true;\n        }\n      } else if (html2.charAt(0) === \"<\") {\n        match = this.startTagRe.exec(html2);\n        if (match) {\n          html2 = RegExp.rightContext;\n          treatAsChars = false;\n          this.parseStartTag(RegExp.lastMatch, match[1], match);\n        } else {\n          treatAsChars = true;\n        }\n      }\n      if (treatAsChars) {\n        index = html2.indexOf(\"<\");\n        if (index === 0) {\n          index = html2.substring(1).indexOf(\"<\");\n        }\n        if (index === -1) {\n          characters = html2;\n          html2 = \"\";\n        } else {\n          characters = html2.substring(0, index);\n          html2 = html2.substring(index);\n        }\n        if (!this.options.ignoreWhitespaceText || !/^\\s*$/.test(characters)) {\n          this.scanner.characters(characters);\n        }\n      }\n      treatAsChars = true;\n      match = null;\n    }\n  }\n  parseStartTag(input, tagName, match) {\n    const isSelfColse = selfCloseTagRe.test(input);\n    let attrInput = match[2];\n    if (isSelfColse) {\n      attrInput = attrInput.replace(/\\s*\\/\\s*$/, \"\");\n    }\n    const attrs = this.parseAttributes(tagName, attrInput);\n    this.scanner.startElement(tagName, attrs, isSelfColse, match[0]);\n  }\n  parseEndTag(input, tagName) {\n    this.scanner.endElement(tagName);\n  }\n  parseAttributes(tagName, input) {\n    const attrs = {};\n    input.replace(this.attrRe, (attr, name, c2, value, c4, valueInQuote, c6, valueInSingleQuote) => {\n      var _ref3, _ref4;\n      attrs[name] = (_ref3 = (_ref4 = valueInSingleQuote !== null && valueInSingleQuote !== void 0 ? valueInSingleQuote : valueInQuote) !== null && _ref4 !== void 0 ? _ref4 : value) !== null && _ref3 !== void 0 ? _ref3 : true;\n    });\n    return attrs;\n  }\n};\n\n// src/vdomparser.ts\nfunction vdom() {\n  let obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  if (obj instanceof VNode) {\n    return obj;\n  }\n  if (obj instanceof Buffer) {\n    obj = obj.toString(\"utf-8\");\n  }\n  if (typeof obj === \"string\") {\n    return parseHTML(obj);\n  }\n  return new VDocumentFragment();\n}\nfunction parseHTML(html2) {\n  if (typeof html2 !== \"string\") {\n    console.error(\"parseHTML requires string, found\", html2);\n    throw new Error(\"parseHTML requires string\");\n  }\n  let frag = html2.indexOf(\"<!\") === 0 ? new VHTMLDocument(true) : new VDocumentFragment();\n  let stack = [frag];\n  let parser = new HtmlParser({\n    scanner: {\n      startElement(tagName, attrs, isSelfClosing) {\n        const lowerTagName = tagName.toLowerCase();\n        if (lowerTagName === \"!doctype\") {\n          frag.docType = new VDocType();\n          return;\n        }\n        for (let name in attrs) {\n          if (attrs.hasOwnProperty(name)) {\n            let value = attrs[name];\n            if (typeof value === \"string\") {\n              attrs[name] = unescapeHTML(value);\n            }\n          }\n        }\n        let parentNode = stack[stack.length - 1];\n        if (parentNode) {\n          const element = document.createElement(tagName, attrs);\n          parentNode.appendChild(element);\n          if (!(SELF_CLOSING_TAGS.includes(tagName.toLowerCase()) || isSelfClosing)) {\n            stack.push(element);\n          }\n        }\n      },\n      endElement(tagName) {\n        stack.pop();\n      },\n      characters(text) {\n        var _a;\n        text = unescapeHTML(text);\n        let parentNode = stack[stack.length - 1];\n        if (((_a = parentNode == null ? void 0 : parentNode.lastChild) == null ? void 0 : _a.nodeType) === VNode.TEXT_NODE) {\n          parentNode.lastChild._text += text;\n        } else {\n          if (parentNode) {\n            parentNode.appendChild(new VTextNode(text));\n          }\n        }\n      },\n      comment(text) {}\n    }\n  });\n  parser.parse(html2);\n  return frag;\n}\nVElement.prototype.setInnerHTML = function (html2) {\n  let frag = parseHTML(html2);\n  this._childNodes = frag._childNodes;\n  this._fixChildNodesParent();\n};\n\n// src/tidy.ts\nvar SELECTOR_BLOCK_ELEMENTS = \"meta,link,script,p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,head,body,title,nav,section,article,hr,form\";\nvar TAGS_KEEP_CONTENT = [\"PRE\", \"CODE\", \"SCRIPT\", \"STYLE\", \"TT\"];\nfunction level(element) {\n  let indent = \"\";\n  while (element.parentNode) {\n    indent += \"  \";\n    element = element.parentNode;\n  }\n  return indent.substr(2);\n}\nfunction tidyDOM(document2) {\n  document2.handle(SELECTOR_BLOCK_ELEMENTS, e => {\n    var _a, _b, _c, _d, _e, _f;\n    let ee = e;\n    while (ee) {\n      if (TAGS_KEEP_CONTENT.includes(ee.tagName)) return;\n      ee = ee.parentNode;\n    }\n    let prev = e.previousSibling;\n    if (!prev || prev.nodeType !== VNode.TEXT_NODE || !((_a = prev.nodeValue) == null ? void 0 : _a.endsWith(\"\\n\"))) {\n      (_b = e.parentNode) == null ? void 0 : _b.insertBefore(new VTextNode(\"\\n\"), e);\n    }\n    (_c = e.parentNode) == null ? void 0 : _c.insertBefore(new VTextNode(level(e)), e);\n    let next = e.nextSibling;\n    if (!next || next.nodeType !== VNode.TEXT_NODE || !((_d = next.nodeValue) == null ? void 0 : _d.startsWith(\"\\n\"))) {\n      if (next) {\n        (_e = e.parentNode) == null ? void 0 : _e.insertBefore(new VTextNode(\"\\n\"), next);\n      } else {\n        (_f = e.parentNode) == null ? void 0 : _f.appendChild(new VTextNode(\"\\n\"));\n      }\n    }\n    if (e.childNodes.length) {\n      let first = e.firstChild;\n      if (first.nodeType === VNode.TEXT_NODE) {\n        e.insertBefore(new VTextNode(\"\\n\" + level(e) + \"  \"));\n      }\n      e.appendChild(new VTextNode(\"\\n\" + level(e)));\n    }\n  });\n}\n\n// src/xml.ts\nfunction xml(itag, iattrs) {\n  for (var _len3 = arguments.length, ichildren = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n    ichildren[_key3 - 2] = arguments[_key3];\n  }\n  let {\n    tag,\n    attrs,\n    children\n  } = hArgumentParser(itag, iattrs, ichildren);\n  return markup(true, tag, attrs, children);\n}\nxml.firstLine = '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\nxml.xml = true;\nexport { CDATA, VDocType, VDocument, VDocumentFragment, VElement, VHTMLDocument, VNode, VNodeQuery, VTextNode, createDocument, createHTMLDocument, document, escapeHTML, h, hArgumentParser, hFactory, html, parseHTML, removeBodyContainer, tidyDOM, unescapeHTML, vdom, xml };","map":{"version":3,"names":["parse","cache","parseSelector","selector","ast","matchSelector","element","debug","arguments","length","undefined","rules","console","log","handleRules","element2","rules2","_a","_b","_c","success","part","type","name","action","value","ignoreCase","data","getAttribute","startsWith","endsWith","classList","contains","includes","hasAttribute","warn","tagName","toUpperCase","ok","forEach","rules3","inspect","Symbol","for","B","fontWeight","I","fontStyle","M","backgroundColor","U","textDecorations","S","DEFAULTS","b","strong","em","i","mark","u","a","s","del","ins","strike","toCamelCase","toLowerCase","replace","m","chr","_VNode","constructor","append","appendChild","_parentNode","_childNodes","nodeType","error","nodeName","nodeValue","cloneNode","deep","node","map","c","_fixChildNodesParent","insertBefore","newNode","index","indexOf","splice","VDocument","VDocumentFragment","Array","isArray","remove","push","text","JSON","stringify","VTextNode","err","concat","render","removeChild","parentNode","replaceChildren","_len","nodes","_key","n","replaceWith","_len2","_key2","p","_indexInParent","childNodes","children","firstChild","lastChild","nextSibling","previousSibling","flatten","elements","VElement","child","flattenNodes","textContent","join","toString","otherNode","some","ownerDocument","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","VNode","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_TYPE_NODE","_text","parentTagName","escapeHTML","VNodeQuery","getElementById","find","e","_attributes","getElementsByClassName","filter","matches","querySelectorAll","querySelector","parent","handle","handler","el","attrs","_originalTagName","_nodeName","_styles","Object","assign","attributes","_findAttributeName","search","keys","name2","setAttribute","removeAttribute","originalName","String","style","styles","styleString","re","exec","trim","id","src","getElementsByTagName","setInnerHTML","html2","innerHTML","html","outerHTML","htmlVDOM","className","entries","_ref","k","v","_ref2","self","classNames","split","add","h2","VDocType","createElement","createDocumentFragment","createTextNode","documentElement","content","docType","VHTMLDocument","empty","body","head","title","titleElement","createDocument","createHTMLDocument","document","h","hFactory","removeBodyContainer","ehead","ebody","body2","attrRe","endTagRe","startTagRe","selfCloseTagRe","HtmlParser","options","defaults","ignoreWhitespaceText","scanner","treatAsChars","match","characters","substring","comment","RegExp","rightContext","parseEndTag","lastMatch","charAt","parseStartTag","test","input","isSelfColse","attrInput","parseAttributes","startElement","endElement","attr","c2","c4","valueInQuote","c6","valueInSingleQuote","_ref3","_ref4","vdom","obj","Buffer","parseHTML","Error","frag","stack","parser","isSelfClosing","lowerTagName","hasOwnProperty","unescapeHTML","SELF_CLOSING_TAGS","pop","prototype","SELECTOR_BLOCK_ELEMENTS","TAGS_KEEP_CONTENT","level","indent","substr","tidyDOM","document2","_d","_e","_f","ee","prev","next","first","xml","itag","iattrs","_len3","ichildren","_key3","tag","hArgumentParser","markup","firstLine"],"sources":["C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\vcss.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\vdom.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\utils.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\htmlparser.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\vdomparser.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\tidy.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\xml.ts"],"sourcesContent":["// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { parse } from \"css-what\"\nimport { VElement } from \"./vdom\"\n\n// Alternative could be https://github.com/leaverou/parsel\n\nlet cache = {}\n\nexport function parseSelector(selector: string) {\n  let ast = cache[selector]\n  if (ast == null) {\n    ast = parse(selector)\n    cache[selector] = ast\n  }\n  return ast\n}\n\n// Just a very small subset for now: https://github.com/fb55/css-what#api\n\nexport function matchSelector(\n  selector: string,\n  element: VElement,\n  { debug = false } = {}\n) {\n  for (let rules of parseSelector(selector)) {\n    if (debug) {\n      console.log(\"Selector:\", selector)\n      console.log(\"Rules:\", rules)\n      console.log(\"Element:\", element)\n    }\n\n    const handleRules = (element: VElement, rules: any[]) => {\n      let success: boolean = false\n      for (let part of rules) {\n        const { type, name, action, value, ignoreCase = true, data } = part\n        if (type === \"attribute\") {\n          if (action === \"equals\") {\n            success = element.getAttribute(name) === value\n            if (debug) console.log(\"Attribute equals\", success)\n          } else if (action === \"start\") {\n            success = !!element.getAttribute(name)?.startsWith(value)\n            if (debug) console.log(\"Attribute start\", success)\n          } else if (action === \"end\") {\n            success = !!element.getAttribute(name)?.endsWith(value)\n            if (debug) console.log(\"Attribute start\", success)\n          } else if (action === \"element\") {\n            if (name === \"class\") {\n              success = element.classList.contains(value)\n              if (debug) console.log(\"Attribute class\", success)\n            } else {\n              success = !!element.getAttribute(name)?.includes(value)\n              if (debug) console.log(\"Attribute element\", success)\n            }\n          } else if (action === \"exists\") {\n            success = element.hasAttribute(name)\n            if (debug) console.log(\"Attribute exists\", success)\n          } else {\n            console.warn(\"Unknown CSS selector action\", action)\n          }\n        } else if (type === \"tag\") {\n          success = element.tagName === name.toUpperCase()\n          if (debug) console.log(\"Is tag\", success)\n        } else if (type === \"universal\") {\n          success = true\n          if (debug) console.log(\"Is universal\", success)\n        } else if (type === \"pseudo\") {\n          if (name === \"not\") {\n            let ok = true\n            data.forEach((rules) => {\n              if (!handleRules(element, rules)) {\n                ok = false\n              }\n            })\n            success = !ok\n          }\n          if (debug) console.log(\"Is :not\", success)\n          // } else if (type === 'descendant') {\n          //   element = element.\n        } else {\n          console.warn(\"Unknown CSS selector type\", type, selector, rules)\n        }\n        // console.log(success, selector, part, element)\n        if (!success) break\n      }\n      return success\n    }\n\n    if (handleRules(element, rules)) {\n      return true\n    }\n  }\n  return false\n}\n","// Copyright (c) 2020 Dirk Holtwick. All rights reserved. https://holtwick.de/copyright\n\nimport { escapeHTML } from \"./encoding\"\nimport { hFactory } from \"./h\"\nimport { html, htmlVDOM } from \"./html\"\nimport { matchSelector } from \"./vcss\"\n\n// For node debugging\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\")\n\nlet B = { fontWeight: \"bold\" }\nlet I = { fontStyle: \"italic\" }\nlet M = { backgroundColor: \"rgb(255, 250, 165)\" }\nlet U = { textDecorations: \"underline\" }\nlet S = { textDecorations: \"line-through\" }\n// let C = {}\n\nlet DEFAULTS = {\n  b: B,\n  strong: B,\n  em: I,\n  i: I,\n  mark: M,\n  u: U,\n  a: U,\n  s: S,\n  del: S,\n  ins: M,\n  strike: S,\n  // 'code': C,\n  // 'tt': C\n}\n\nlet toCamelCase = (s: string) =>\n  s.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase())\n\nexport class VNode {\n  static ELEMENT_NODE = 1\n  static TEXT_NODE = 3\n  static CDATA_SECTION_NODE = 4\n  static PROCESSING_INSTRUCTION_NODE = 7\n  static COMMENT_NODE = 8\n  static DOCUMENT_NODE = 9\n  static DOCUMENT_TYPE_NODE = 10\n  static DOCUMENT_FRAGMENT_NODE = 11\n\n  _parentNode: any\n  _childNodes: any[]\n\n  get nodeType(): number {\n    console.error(\"Subclasses should define nodeType!\")\n    return 0\n  }\n\n  get nodeName() {\n    console.error(\"Subclasses should define nodeName!\")\n    return \"\"\n  }\n\n  get nodeValue(): string | null {\n    return null\n  }\n\n  constructor() {\n    this._parentNode = null\n    this._childNodes = []\n  }\n\n  cloneNode(deep = false) {\n    // @ts-ignore\n    let node = new this.constructor()\n    if (deep) {\n      node._childNodes = this._childNodes.map((c) => c.cloneNode(true))\n      node._fixChildNodesParent()\n    }\n    return node\n  }\n\n  _fixChildNodesParent() {\n    this._childNodes.forEach((node) => (node._parentNode = this))\n  }\n\n  insertBefore(newNode: VNode, node?: VNode) {\n    if (newNode !== node) {\n      let index = node ? this._childNodes.indexOf(node) : 0\n      if (index < 0) index = 0\n      this._childNodes.splice(index, 0, newNode)\n      this._fixChildNodesParent()\n    }\n  }\n\n  appendChild(node: VNode | VNode[] | string | string[] | null | undefined) {\n    if (node == null) return\n    if (node === this) {\n      console.warn(\"Cannot appendChild to self\")\n      return\n    }\n    // log('appendChild', node, this)\n\n    if (node instanceof VDocument) {\n      console.warn(\"No defined how to append a document to a node!\", node)\n    }\n\n    if (node instanceof VDocumentFragment) {\n      for (let c of [...node._childNodes]) {\n        // Don't iterate over the original! Do [...el]\n        this.appendChild(c)\n      }\n    } else if (Array.isArray(node)) {\n      for (let c of [...node]) {\n        // Don't iterate over the original! Do [...el]\n        this.appendChild(c)\n      }\n    } else if (node instanceof VNode) {\n      node.remove()\n      this._childNodes.push(node)\n    } else {\n      // Fallback for unknown data\n      try {\n        const text =\n          typeof node === \"string\" ? node : JSON.stringify(node, null, 2)\n        this._childNodes.push(new VTextNode(text))\n      } catch (err) {\n        console.error(\n          `The data ${node} to be added to ${this.render()} is problematic: ${err}`\n        )\n      }\n    }\n    this._fixChildNodesParent()\n  }\n\n  append = this.appendChild\n\n  removeChild(node: { _parentNode: null }) {\n    let i = this._childNodes.indexOf(node)\n    if (i >= 0) {\n      node._parentNode = null\n      this._childNodes.splice(i, 1)\n      this._fixChildNodesParent()\n    }\n  }\n\n  remove() {\n    this?.parentNode?.removeChild(this)\n    return this\n  }\n\n  replaceChildren(...nodes: any[]) {\n    this._childNodes = nodes.map((n) =>\n      typeof n === \"string\" ? new VTextNode(n) : n.remove()\n    )\n    this._fixChildNodesParent()\n  }\n\n  replaceWith(...nodes: any[]) {\n    let p = this._parentNode\n    if (p) {\n      let index = this._indexInParent()\n      if (index >= 0) {\n        nodes = nodes.map((n) =>\n          typeof n === \"string\" ? new VTextNode(n) : n.remove()\n        )\n        p._childNodes.splice(index, 1, ...nodes)\n        this._parentNode = null\n        p._fixChildNodesParent()\n      }\n    }\n  }\n\n  _indexInParent() {\n    if (this._parentNode) {\n      return this._parentNode.childNodes.indexOf(this)\n    }\n    return -1\n  }\n\n  get parentNode() {\n    return this._parentNode\n  }\n\n  get childNodes() {\n    return this._childNodes || []\n  }\n\n  get children() {\n    return this._childNodes || []\n  }\n\n  get firstChild() {\n    return this._childNodes[0]\n  }\n\n  get lastChild() {\n    return this._childNodes[this._childNodes.length - 1]\n  }\n\n  get nextSibling() {\n    let i = this._indexInParent()\n    if (i != null) {\n      return this.parentNode.childNodes[i + 1] || null\n    }\n    return null\n  }\n\n  get previousSibling() {\n    let i = this._indexInParent()\n    if (i > 0) {\n      return this.parentNode.childNodes[i - 1] || null\n    }\n    return null\n  }\n\n  flatten(): VElement[] {\n    let elements: VElement[] = []\n    if (this instanceof VElement) {\n      elements.push(this)\n    }\n    for (let child of this._childNodes) {\n      elements.push(...child.flatten())\n    }\n    return elements\n  }\n\n  flattenNodes(): VNode[] {\n    let nodes: VNode[] = []\n    nodes.push(this)\n    for (let child of this._childNodes) {\n      nodes.push(...child.flattenNodes())\n    }\n    return nodes\n  }\n\n  render() {\n    return \"\"\n  }\n\n  get textContent(): string | null {\n    return this._childNodes.map((c) => c.textContent).join(\"\")\n  }\n\n  set textContent(text) {\n    this._childNodes = []\n    if (text) {\n      this.appendChild(new VTextNode(text.toString()))\n    }\n  }\n\n  contains(otherNode: this) {\n    if (otherNode === this) return true\n    // if (this._childNodes.includes(otherNode)) return true\n    return this._childNodes.some((n) => n.contains(otherNode))\n  }\n\n  get ownerDocument() {\n    if (\n      this.nodeType === VNode.DOCUMENT_NODE ||\n      this.nodeType === VNode.DOCUMENT_FRAGMENT_NODE\n    ) {\n      return this\n    }\n    return this?._parentNode?.ownerDocument\n  }\n\n  toString(): string {\n    return `${this.nodeName}`\n    // return `${this.nodeName}: ${JSON.stringify(this.nodeValue)}`\n  }\n\n  [inspect]() {\n    return `${this.constructor.name} \"${this.render()}\"`\n  }\n}\n\nexport class VTextNode extends VNode {\n  _text: string\n\n  get nodeType(): number {\n    return VNode.TEXT_NODE\n  }\n\n  get nodeName() {\n    return \"#text\"\n  }\n\n  get nodeValue(): string | null {\n    return this._text || \"\"\n  }\n\n  get textContent(): string | null {\n    return this.nodeValue\n  }\n\n  constructor(text = \"\") {\n    super()\n    this._text = text\n  }\n\n  render() {\n    const parentTagName = this.parentNode?.tagName\n    if (parentTagName === \"SCRIPT\" || parentTagName === \"STYLE\") {\n      return this._text\n    }\n    return escapeHTML(this._text)\n  }\n\n  cloneNode(deep = false) {\n    let node = super.cloneNode(deep)\n    node._text = this._text\n    return node\n  }\n}\n\nexport class VNodeQuery extends VNode {\n  getElementById(name: string) {\n    return this.flatten().find((e) => e._attributes[\"id\"] === name)\n  }\n\n  getElementsByClassName(name: any) {\n    return this.flatten().filter((e) => e.classList.contains(name))\n  }\n\n  matches(selector: string) {\n    return matchSelector(selector, this as any)\n  }\n\n  querySelectorAll(selector: any) {\n    return this.flatten().filter((e) => e.matches(selector))\n  }\n\n  querySelector(selector: string) {\n    return this.flatten().find((e) => e.matches(selector))\n  }\n\n  //\n\n  parent(selector: string) {\n    if (this.matches(selector)) {\n      return this\n    }\n    if (this.parentNode == null) {\n      return null\n    }\n    return this.parentNode?.parent(selector)\n  }\n\n  handle(selector: any, handler: (arg0: VElement, arg1: number) => void) {\n    let i = 0\n    for (let el of this.querySelectorAll(selector)) {\n      handler(el, i++)\n    }\n  }\n}\n\nexport class VElement extends VNodeQuery {\n  _originalTagName: string\n  _nodeName: any\n  _attributes: Record<string, string>\n  _styles: any\n\n  get nodeType() {\n    return VNode.ELEMENT_NODE\n  }\n\n  get nodeName() {\n    return this._nodeName\n  }\n\n  constructor(name = \"div\", attrs = {}) {\n    super()\n    this._originalTagName = name\n    this._nodeName = (name || \"\").toUpperCase()\n    this._attributes = attrs || {}\n    this._styles = null\n  }\n\n  cloneNode(deep = false) {\n    let node = super.cloneNode(deep)\n    node._originalTagName = this._originalTagName\n    node._nodeName = this._nodeName\n    node._attributes = Object.assign({}, this._attributes)\n    return node\n  }\n\n  get attributes() {\n    return this._attributes\n  }\n\n  _findAttributeName(name: string) {\n    const search = name.toLowerCase()\n    return (\n      Object.keys(this._attributes).find(\n        (name) => search === name.toLowerCase()\n      ) || null\n    )\n  }\n\n  setAttribute(name: string, value: string) {\n    this.removeAttribute(name)\n    this._attributes[name] = value\n    this._styles = null\n  }\n\n  getAttribute(name: string): string | null {\n    const originalName = this._findAttributeName(name)\n    return originalName ? this._attributes[originalName] : null\n  }\n\n  removeAttribute(name: string | number) {\n    const originalName = this._findAttributeName(String(name))\n    if (originalName) {\n      delete this._attributes[name]\n    }\n  }\n\n  hasAttribute(name: any) {\n    const originalName = this._findAttributeName(name)\n    return originalName ? this._attributes[originalName] != null : false\n  }\n\n  get style() {\n    if (this._styles == null) {\n      let styles = Object.assign({}, DEFAULTS[this.tagName.toLowerCase()] || {})\n      let styleString = this.getAttribute(\"style\")\n      if (styleString) {\n        let m: string[] | null\n        let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g\n        while ((m = re.exec(styleString))) {\n          let name = m[1]\n          let value = m[2].trim()\n          styles[name] = value\n          styles[toCamelCase(name)] = value\n        }\n      }\n      this._styles = styles\n    }\n    return this._styles\n  }\n\n  get tagName() {\n    return this._nodeName\n  }\n\n  get id(): string | null {\n    return this._attributes.id || null\n  }\n\n  set id(value: string | null) {\n    if (value == null) delete this._attributes.id\n    else this._attributes.id = value\n  }\n\n  get src(): string | null {\n    return this._attributes.src\n  }\n\n  set src(value: string | null) {\n    if (value == null) delete this._attributes.src\n    else this._attributes.src = value\n  }\n\n  //\n\n  getElementsByTagName(name: string) {\n    name = name.toUpperCase()\n    let elements = this.flatten()\n    if (name !== \"*\") {\n      return elements.filter((e) => e.tagName === name)\n    }\n    return elements\n  }\n\n  // html\n\n  setInnerHTML(html: string) {\n    throw \"setInnerHTML is not implemented; see vdomparser for an example\"\n  }\n\n  get innerHTML() {\n    return this._childNodes.map((c) => c.render(html)).join(\"\")\n  }\n\n  set innerHTML(html) {\n    this.setInnerHTML(html)\n  }\n\n  get outerHTML() {\n    return this.render(htmlVDOM)\n  }\n\n  // class\n\n  get className(): string {\n    return this._attributes[\"class\"] || \"\"\n  }\n\n  set className(name: string | string[]) {\n    if (Array.isArray(name)) {\n      name = name.filter((n) => !!n).join(\" \")\n    } else if (typeof name === \"object\") {\n      name = Object.entries(name)\n        .filter(([k, v]) => !!v)\n        .map(([k, v]) => k)\n        .join(\" \")\n    }\n    this._attributes[\"class\"] = name\n  }\n\n  get classList() {\n    let self = this\n    let classNames = (this.className || \"\").trim().split(/\\s+/g) || []\n    // log('classList', classNames)\n    return {\n      contains(s: any) {\n        return classNames.includes(s)\n      },\n      add(s: any) {\n        if (!classNames.includes(s)) {\n          classNames.push(s)\n          self.className = classNames\n        }\n      },\n      remove(s: any) {\n        let index = classNames.indexOf(s)\n        if (index >= 0) {\n          classNames.splice(index, 1)\n          self.className = classNames\n        }\n      },\n    }\n  }\n\n  //\n\n  render(h = htmlVDOM) {\n    return h(\n      this._originalTagName || this.tagName,\n      this.attributes,\n      this._childNodes.map((c) => c.render(h)).join(\"\") // children:string is not escaped again\n    )\n  }\n}\n\nexport class VDocType extends VNode {\n  //todo\n\n  name: any\n  publicId: any\n  systemId: any\n\n  get nodeName(): string {\n    return super.nodeName\n  }\n\n  get nodeValue(): string | null {\n    return super.nodeValue\n  }\n\n  get nodeType(): number {\n    return VDocType.DOCUMENT_TYPE_NODE\n  }\n\n  render() {\n    return `<!DOCTYPE html>` // hack!\n  }\n}\n\nexport class VDocumentFragment extends VNodeQuery {\n  docType: VDocType\n\n  get nodeType() {\n    return VNode.DOCUMENT_FRAGMENT_NODE\n  }\n\n  get nodeName() {\n    return \"#document-fragment\"\n  }\n\n  render(h = htmlVDOM) {\n    return this._childNodes.map((c) => c.render(h) || []).join(\"\")\n  }\n\n  get innerHTML() {\n    // for debug\n    return this._childNodes.map((c) => c.render(html)).join(\"\")\n  }\n\n  createElement(name: string, attrs = {}) {\n    return new VElement(name, attrs)\n  }\n\n  createDocumentFragment() {\n    return new VDocumentFragment()\n  }\n\n  createTextNode(text?: string) {\n    return new VTextNode(text)\n  }\n}\n\nexport class VDocument extends VDocumentFragment {\n  get nodeType() {\n    return VNode.DOCUMENT_NODE\n  }\n\n  get nodeName() {\n    return \"#document\"\n  }\n\n  get documentElement() {\n    return this.firstChild\n  }\n\n  render(h = htmlVDOM) {\n    let content = super.render(h)\n    if (this.docType) {\n      content = this.docType.render() + content\n    }\n    return content\n  }\n}\n\nexport class VHTMLDocument extends VDocument {\n  constructor(empty: boolean = false) {\n    super()\n    this.docType = new VDocType()\n    if (!empty) {\n      let html = new VElement(\"html\")\n      let body = new VElement(\"body\")\n      let head = new VElement(\"head\")\n      let title = new VElement(\"title\")\n      html.appendChild(head)\n      head.appendChild(title)\n      html.appendChild(body)\n      this.appendChild(html)\n    }\n  }\n\n  get body(): VElement {\n    let body = this.querySelector(\"body\")\n    if (!body) {\n      let html = this.querySelector(\"html\")\n      if (!html) {\n        html = new VElement(\"html\")\n        this.appendChild(html)\n      }\n      body = new VElement(\"body\")\n      html.appendChild(html)\n    }\n    return body\n  }\n\n  get title(): string {\n    return this.querySelector(\"title\")?.textContent || \"\"\n  }\n\n  set title(title: string) {\n    const titleElement = this.querySelector(\"title\")\n    if (titleElement) titleElement.textContent = title\n  }\n\n  get head(): VElement {\n    let head = this.querySelector(\"head\")\n    if (!head) {\n      let html = this.querySelector(\"html\")\n      if (!html) {\n        html = new VElement(\"html\")\n        this.appendChild(html)\n      }\n      head = new VElement(\"head\")\n      html.insertBefore(html)\n    }\n    return head\n  }\n}\n\nexport function createDocument(): VDocument {\n  return new VDocument()\n}\n\nexport function createHTMLDocument(): VHTMLDocument {\n  return new VHTMLDocument()\n}\n\nexport let document = createDocument()\nexport let h = hFactory({ document })\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { VDocumentFragment, VNodeQuery } from \"./vdom\"\n\nexport function removeBodyContainer(body: VNodeQuery): VNodeQuery {\n  let ehead = body.querySelector(\"head\")\n  let ebody = body.querySelector(\"body\")\n  if (ebody || ehead) {\n    let body = new VDocumentFragment()\n    ehead && body.appendChild(ehead.childNodes)\n    ebody && body.appendChild(ebody.children)\n    return body\n  }\n  return body\n}\n","// Taken from https://github.com/creeperyang/html-parser-lite\n// and slightly modified. Original also under MIT license. Thanks.\n\n// attribute, like href=\"javascript:void(0)\"\n// 1. start with name (not empty and not =)\n// 2. and then \\s*=\\s*\n// 3. and value can be \"value\" | 'value' | value\n// 4. 2 and 3 are optional\nconst attrRe = /([^=\\s]+)(\\s*=\\s*((\"([^\"]*)\")|('([^']*)')|[^>\\s]+))?/gm\nconst endTagRe = /^<\\/([^>\\s]+)[^>]*>/m\n// start tag, like <a href=\"link\"> <img/>\n// 1. must start with <tagName\n// 2. optional attrbutes\n// 3. /> or >\nconst startTagRe =\n  /^<([^>\\s\\/]+)((\\s+[^=>\\s]+(\\s*=\\s*((\"[^\"]*\")|('[^']*')|[^>\\s]+))?)*)\\s*\\/?\\s*>/m\nconst selfCloseTagRe = /\\s*\\/\\s*>\\s*$/m\n\n/**\n * This is a simple html parser. Will read and parse html string.\n *\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nexport class HtmlParser {\n  scanner: any\n  options: any\n  attrRe = attrRe\n  endTagRe = endTagRe\n  startTagRe = startTagRe\n  defaults = { ignoreWhitespaceText: false }\n\n  constructor(options) {\n    options = options || {}\n    if (options.scanner) {\n      this.scanner = options.scanner\n      options.scanner = null\n    }\n    this.options = Object.assign({}, this.defaults, options)\n  }\n\n  parse(html: string) {\n    let treatAsChars = false\n    let index, match, characters\n    while (html.length) {\n      // comment\n      if (html.substring(0, 4) === \"<!--\") {\n        index = html.indexOf(\"-->\")\n        if (index !== -1) {\n          this.scanner.comment(html.substring(4, index))\n          html = html.substring(index + 3)\n          treatAsChars = false\n        } else {\n          treatAsChars = true\n        }\n      }\n      // end tag\n      else if (html.substring(0, 2) === \"</\") {\n        match = this.endTagRe.exec(html)\n        if (match) {\n          // @ts-ignore\n          html = RegExp.rightContext\n          treatAsChars = false\n          this.parseEndTag(RegExp.lastMatch, match[1])\n        } else {\n          treatAsChars = true\n        }\n      }\n      // start tag\n      else if (html.charAt(0) === \"<\") {\n        match = this.startTagRe.exec(html)\n        if (match) {\n          // @ts-ignore\n          html = RegExp.rightContext\n          treatAsChars = false\n          this.parseStartTag(RegExp.lastMatch, match[1], match)\n        } else {\n          treatAsChars = true\n        }\n      }\n\n      if (treatAsChars) {\n        index = html.indexOf(\"<\")\n\n        if (index === 0) {\n          // First char is a < so find the next one\n          index = html.substring(1).indexOf(\"<\")\n        }\n\n        if (index === -1) {\n          characters = html\n          html = \"\"\n        } else {\n          characters = html.substring(0, index)\n          html = html.substring(index)\n        }\n\n        if (!this.options.ignoreWhitespaceText || !/^\\s*$/.test(characters)) {\n          this.scanner.characters(characters)\n        }\n      }\n\n      treatAsChars = true\n      match = null\n    }\n  }\n\n  parseStartTag(input, tagName, match) {\n    const isSelfColse = selfCloseTagRe.test(input)\n    let attrInput = match[2]\n    if (isSelfColse) {\n      attrInput = attrInput.replace(/\\s*\\/\\s*$/, \"\")\n    }\n    const attrs = this.parseAttributes(tagName, attrInput)\n    this.scanner.startElement(tagName, attrs, isSelfColse, match[0])\n  }\n\n  parseEndTag(input, tagName: string) {\n    this.scanner.endElement(tagName)\n  }\n\n  parseAttributes(tagName, input) {\n    const attrs = {}\n    input.replace(\n      this.attrRe,\n      (attr, name, c2, value, c4, valueInQuote, c6, valueInSingleQuote) => {\n        attrs[name] = valueInSingleQuote ?? valueInQuote ?? value ?? true\n      }\n    )\n    return attrs\n  }\n}\n","// Copyright (c) 2020 Dirk Holtwick. All rights reserved. https://holtwick.de/copyright\n\nimport { unescapeHTML } from \"./encoding\"\nimport { SELF_CLOSING_TAGS } from \"./html\"\nimport { HtmlParser } from \"./htmlparser\"\nimport {\n  document,\n  VDocType,\n  VDocumentFragment,\n  VElement,\n  VHTMLDocument,\n  VNode,\n  VTextNode,\n} from \"./vdom\"\n\n// Makes sure we operate on VNodes\nexport function vdom(obj: VNode | Buffer | string | null = null): VNode {\n  if (obj instanceof VNode) {\n    return obj\n  }\n  if (obj instanceof Buffer) {\n    obj = obj.toString(\"utf-8\")\n  }\n  if (typeof obj === \"string\") {\n    return parseHTML(obj)\n  }\n  // console.warn('Cannot convert to VDOM:', obj)\n  return new VDocumentFragment()\n}\n\nexport function parseHTML(html: string): VDocumentFragment | VHTMLDocument {\n  if (typeof html !== \"string\") {\n    console.error(\"parseHTML requires string, found\", html)\n    throw new Error(\"parseHTML requires string\")\n  }\n\n  let frag =\n    html.indexOf(\"<!\") === 0 ? new VHTMLDocument(true) : new VDocumentFragment() // !hack\n\n  let stack: VNode[] = [frag]\n\n  let parser = new HtmlParser({\n    // the for methods must be implemented yourself\n    scanner: {\n      startElement(\n        tagName: string,\n        attrs: Record<string, string>,\n        isSelfClosing: boolean\n      ) {\n        const lowerTagName = tagName.toLowerCase()\n\n        if (lowerTagName === \"!doctype\") {\n          frag.docType = new VDocType()\n          return\n        }\n\n        for (let name in attrs) {\n          if (attrs.hasOwnProperty(name)) {\n            let value = attrs[name]\n            // console.log(name, value)\n            if (typeof value === \"string\") {\n              attrs[name] = unescapeHTML(value)\n            }\n          }\n        }\n        let parentNode = stack[stack.length - 1]\n        if (parentNode) {\n          const element = document.createElement(tagName, attrs)\n          parentNode.appendChild(element)\n          if (\n            !(\n              SELF_CLOSING_TAGS.includes(tagName.toLowerCase()) || isSelfClosing\n            )\n          ) {\n            stack.push(element)\n          }\n        }\n      },\n      endElement(tagName: string) {\n        stack.pop()\n      },\n      characters(text: string) {\n        text = unescapeHTML(text)\n        let parentNode = stack[stack.length - 1]\n        if (parentNode?.lastChild?.nodeType === VNode.TEXT_NODE) {\n          parentNode.lastChild._text += text\n        } else {\n          if (parentNode) {\n            parentNode.appendChild(new VTextNode(text))\n            // } else {\n            //   console.trace(parentNode, stack)\n          }\n        }\n      },\n      comment(text: string) {},\n    },\n  })\n  parser.parse(html)\n  // console.log(\"frag\", frag)\n  return frag\n}\n\n// export function parseHTML2(html) {\n//   let frag = new VDocumentFragment()\n//\n//   let stack = [frag]\n//   let currentElement = frag\n//\n//   let parser = new Parser({\n//     onopentag: (name, attrs) => {\n//       let element = document.createElement(name, attrs)\n//       stack.push(element)\n//       currentElement.appendChild(element)\n//       currentElement = element\n//     },\n//     ontext: function (text) {\n//       if (currentElement?.lastChild?.nodeType === VNode.TEXT_NODE) {\n//         currentElement.lastChild._text += text\n//       } else {\n//         currentElement.appendChild(new VTextNode(text))\n//       }\n//     },\n//     onclosetag: function (name) {\n//       let element = stack.pop()\n//       currentElement = stack[stack.length - 1]\n//       // if (element.nodeName !== currentElement.nodeName) {\n//       //   console.log('error', element, currentElement)\n//       // }\n//     },\n//   }, { decodeEntities: true })\n//   parser.write(html)\n//   parser.end()\n//\n//   // console.log('frag', frag.innerHTML)\n//\n//   return frag\n// }\n\nVElement.prototype.setInnerHTML = function (html) {\n  let frag = parseHTML(html)\n  this._childNodes = frag._childNodes\n  this._fixChildNodesParent()\n}\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { VDocument, VNode, VTextNode } from \"./vdom\"\n\nconst SELECTOR_BLOCK_ELEMENTS =\n  \"meta,link,script,p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,head,body,title,nav,section,article,hr,form\"\nconst TAGS_KEEP_CONTENT = [\"PRE\", \"CODE\", \"SCRIPT\", \"STYLE\", \"TT\"]\n\nfunction level(element: VNode): string {\n  let indent = \"\"\n  while (element.parentNode) {\n    indent += \"  \"\n    element = element.parentNode\n  }\n  return indent.substr(2)\n}\n\nexport function tidyDOM(document: VDocument) {\n  document.handle(SELECTOR_BLOCK_ELEMENTS, (e) => {\n    // Ignore if inside PRE etc.\n    let ee = e\n    while (ee) {\n      if (TAGS_KEEP_CONTENT.includes(ee.tagName)) return\n      ee = ee.parentNode\n    }\n\n    let prev = e.previousSibling\n    if (\n      !prev ||\n      prev.nodeType !== VNode.TEXT_NODE ||\n      !prev.nodeValue?.endsWith(\"\\n\")\n    ) {\n      e.parentNode?.insertBefore(new VTextNode(\"\\n\"), e)\n    }\n    e.parentNode?.insertBefore(new VTextNode(level(e)), e)\n\n    let next = e.nextSibling\n    if (\n      !next ||\n      next.nodeType !== VNode.TEXT_NODE ||\n      !next.nodeValue?.startsWith(\"\\n\")\n    ) {\n      if (next) {\n        e.parentNode?.insertBefore(new VTextNode(\"\\n\"), next)\n      } else {\n        e.parentNode?.appendChild(new VTextNode(\"\\n\"))\n      }\n    }\n\n    if (e.childNodes.length) {\n      let first = e.firstChild\n      if (first.nodeType === VNode.TEXT_NODE) {\n        e.insertBefore(new VTextNode(\"\\n\" + level(e) + \"  \"))\n      }\n      e.appendChild(new VTextNode(\"\\n\" + level(e)))\n    }\n  })\n}\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { hArgumentParser } from \"./h\"\nimport { markup } from \"./html\"\n\nexport function xml(itag: string, iattrs?: object, ...ichildren: any[]) {\n  let { tag, attrs, children } = hArgumentParser(itag, iattrs, ichildren)\n  return markup(true, tag, attrs, children)\n}\n\n// export const xmlVDOM = markup.bind(null, true)\n\nxml.firstLine = '<?xml version=\"1.0\" encoding=\"utf-8\"?>'\nxml.xml = true\n\nexport let h = xml\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { CDATA, SELF_CLOSING_TAGS, escapeHTML, hArgumentParser, hFactory, html, htmlVDOM, markup, unescapeHTML } from \"./chunk-B6CCJBSJ.js\";\n\n// src/vcss.ts\nimport { parse } from \"css-what\";\nvar cache = {};\nfunction parseSelector(selector) {\n  let ast = cache[selector];\n  if (ast == null) {\n    ast = parse(selector);\n    cache[selector] = ast;\n  }\n  return ast;\n}\nfunction matchSelector(selector, element, {\n  debug = false\n} = {}) {\n  for (let rules of parseSelector(selector)) {\n    if (debug) {\n      console.log(\"Selector:\", selector);\n      console.log(\"Rules:\", rules);\n      console.log(\"Element:\", element);\n    }\n    const handleRules = (element2, rules2) => {\n      var _a, _b, _c;\n      let success = false;\n      for (let part of rules2) {\n        const {\n          type,\n          name,\n          action,\n          value,\n          ignoreCase = true,\n          data\n        } = part;\n        if (type === \"attribute\") {\n          if (action === \"equals\") {\n            success = element2.getAttribute(name) === value;\n            if (debug) console.log(\"Attribute equals\", success);\n          } else if (action === \"start\") {\n            success = !!((_a = element2.getAttribute(name)) == null ? void 0 : _a.startsWith(value));\n            if (debug) console.log(\"Attribute start\", success);\n          } else if (action === \"end\") {\n            success = !!((_b = element2.getAttribute(name)) == null ? void 0 : _b.endsWith(value));\n            if (debug) console.log(\"Attribute start\", success);\n          } else if (action === \"element\") {\n            if (name === \"class\") {\n              success = element2.classList.contains(value);\n              if (debug) console.log(\"Attribute class\", success);\n            } else {\n              success = !!((_c = element2.getAttribute(name)) == null ? void 0 : _c.includes(value));\n              if (debug) console.log(\"Attribute element\", success);\n            }\n          } else if (action === \"exists\") {\n            success = element2.hasAttribute(name);\n            if (debug) console.log(\"Attribute exists\", success);\n          } else {\n            console.warn(\"Unknown CSS selector action\", action);\n          }\n        } else if (type === \"tag\") {\n          success = element2.tagName === name.toUpperCase();\n          if (debug) console.log(\"Is tag\", success);\n        } else if (type === \"universal\") {\n          success = true;\n          if (debug) console.log(\"Is universal\", success);\n        } else if (type === \"pseudo\") {\n          if (name === \"not\") {\n            let ok = true;\n            data.forEach(rules3 => {\n              if (!handleRules(element2, rules3)) {\n                ok = false;\n              }\n            });\n            success = !ok;\n          }\n          if (debug) console.log(\"Is :not\", success);\n        } else {\n          console.warn(\"Unknown CSS selector type\", type, selector, rules2);\n        }\n        if (!success) break;\n      }\n      return success;\n    };\n    if (handleRules(element, rules)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/vdom.ts\nvar inspect = Symbol.for(\"nodejs.util.inspect.custom\");\nvar B = {\n  fontWeight: \"bold\"\n};\nvar I = {\n  fontStyle: \"italic\"\n};\nvar M = {\n  backgroundColor: \"rgb(255, 250, 165)\"\n};\nvar U = {\n  textDecorations: \"underline\"\n};\nvar S = {\n  textDecorations: \"line-through\"\n};\nvar DEFAULTS = {\n  b: B,\n  strong: B,\n  em: I,\n  i: I,\n  mark: M,\n  u: U,\n  a: U,\n  s: S,\n  del: S,\n  ins: M,\n  strike: S\n};\nvar toCamelCase = s => s.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase());\nvar _VNode = class {\n  constructor() {\n    this.append = this.appendChild;\n    this._parentNode = null;\n    this._childNodes = [];\n  }\n  get nodeType() {\n    console.error(\"Subclasses should define nodeType!\");\n    return 0;\n  }\n  get nodeName() {\n    console.error(\"Subclasses should define nodeName!\");\n    return \"\";\n  }\n  get nodeValue() {\n    return null;\n  }\n  cloneNode(deep = false) {\n    let node = new this.constructor();\n    if (deep) {\n      node._childNodes = this._childNodes.map(c => c.cloneNode(true));\n      node._fixChildNodesParent();\n    }\n    return node;\n  }\n  _fixChildNodesParent() {\n    this._childNodes.forEach(node => node._parentNode = this);\n  }\n  insertBefore(newNode, node) {\n    if (newNode !== node) {\n      let index = node ? this._childNodes.indexOf(node) : 0;\n      if (index < 0) index = 0;\n      this._childNodes.splice(index, 0, newNode);\n      this._fixChildNodesParent();\n    }\n  }\n  appendChild(node) {\n    if (node == null) return;\n    if (node === this) {\n      console.warn(\"Cannot appendChild to self\");\n      return;\n    }\n    if (node instanceof VDocument) {\n      console.warn(\"No defined how to append a document to a node!\", node);\n    }\n    if (node instanceof VDocumentFragment) {\n      for (let c of [...node._childNodes]) {\n        this.appendChild(c);\n      }\n    } else if (Array.isArray(node)) {\n      for (let c of [...node]) {\n        this.appendChild(c);\n      }\n    } else if (node instanceof _VNode) {\n      node.remove();\n      this._childNodes.push(node);\n    } else {\n      try {\n        const text = typeof node === \"string\" ? node : JSON.stringify(node, null, 2);\n        this._childNodes.push(new VTextNode(text));\n      } catch (err) {\n        console.error(`The data ${node} to be added to ${this.render()} is problematic: ${err}`);\n      }\n    }\n    this._fixChildNodesParent();\n  }\n  removeChild(node) {\n    let i = this._childNodes.indexOf(node);\n    if (i >= 0) {\n      node._parentNode = null;\n      this._childNodes.splice(i, 1);\n      this._fixChildNodesParent();\n    }\n  }\n  remove() {\n    var _a;\n    (_a = this == null ? void 0 : this.parentNode) == null ? void 0 : _a.removeChild(this);\n    return this;\n  }\n  replaceChildren(...nodes) {\n    this._childNodes = nodes.map(n => typeof n === \"string\" ? new VTextNode(n) : n.remove());\n    this._fixChildNodesParent();\n  }\n  replaceWith(...nodes) {\n    let p = this._parentNode;\n    if (p) {\n      let index = this._indexInParent();\n      if (index >= 0) {\n        nodes = nodes.map(n => typeof n === \"string\" ? new VTextNode(n) : n.remove());\n        p._childNodes.splice(index, 1, ...nodes);\n        this._parentNode = null;\n        p._fixChildNodesParent();\n      }\n    }\n  }\n  _indexInParent() {\n    if (this._parentNode) {\n      return this._parentNode.childNodes.indexOf(this);\n    }\n    return -1;\n  }\n  get parentNode() {\n    return this._parentNode;\n  }\n  get childNodes() {\n    return this._childNodes || [];\n  }\n  get children() {\n    return this._childNodes || [];\n  }\n  get firstChild() {\n    return this._childNodes[0];\n  }\n  get lastChild() {\n    return this._childNodes[this._childNodes.length - 1];\n  }\n  get nextSibling() {\n    let i = this._indexInParent();\n    if (i != null) {\n      return this.parentNode.childNodes[i + 1] || null;\n    }\n    return null;\n  }\n  get previousSibling() {\n    let i = this._indexInParent();\n    if (i > 0) {\n      return this.parentNode.childNodes[i - 1] || null;\n    }\n    return null;\n  }\n  flatten() {\n    let elements = [];\n    if (this instanceof VElement) {\n      elements.push(this);\n    }\n    for (let child of this._childNodes) {\n      elements.push(...child.flatten());\n    }\n    return elements;\n  }\n  flattenNodes() {\n    let nodes = [];\n    nodes.push(this);\n    for (let child of this._childNodes) {\n      nodes.push(...child.flattenNodes());\n    }\n    return nodes;\n  }\n  render() {\n    return \"\";\n  }\n  get textContent() {\n    return this._childNodes.map(c => c.textContent).join(\"\");\n  }\n  set textContent(text) {\n    this._childNodes = [];\n    if (text) {\n      this.appendChild(new VTextNode(text.toString()));\n    }\n  }\n  contains(otherNode) {\n    if (otherNode === this) return true;\n    return this._childNodes.some(n => n.contains(otherNode));\n  }\n  get ownerDocument() {\n    var _a;\n    if (this.nodeType === _VNode.DOCUMENT_NODE || this.nodeType === _VNode.DOCUMENT_FRAGMENT_NODE) {\n      return this;\n    }\n    return (_a = this == null ? void 0 : this._parentNode) == null ? void 0 : _a.ownerDocument;\n  }\n  toString() {\n    return `${this.nodeName}`;\n  }\n  [inspect]() {\n    return `${this.constructor.name} \"${this.render()}\"`;\n  }\n};\nvar VNode = _VNode;\nVNode.ELEMENT_NODE = 1;\nVNode.TEXT_NODE = 3;\nVNode.CDATA_SECTION_NODE = 4;\nVNode.PROCESSING_INSTRUCTION_NODE = 7;\nVNode.COMMENT_NODE = 8;\nVNode.DOCUMENT_NODE = 9;\nVNode.DOCUMENT_TYPE_NODE = 10;\nVNode.DOCUMENT_FRAGMENT_NODE = 11;\nvar VTextNode = class extends VNode {\n  constructor(text = \"\") {\n    super();\n    this._text = text;\n  }\n  get nodeType() {\n    return VNode.TEXT_NODE;\n  }\n  get nodeName() {\n    return \"#text\";\n  }\n  get nodeValue() {\n    return this._text || \"\";\n  }\n  get textContent() {\n    return this.nodeValue;\n  }\n  render() {\n    var _a;\n    const parentTagName = (_a = this.parentNode) == null ? void 0 : _a.tagName;\n    if (parentTagName === \"SCRIPT\" || parentTagName === \"STYLE\") {\n      return this._text;\n    }\n    return escapeHTML(this._text);\n  }\n  cloneNode(deep = false) {\n    let node = super.cloneNode(deep);\n    node._text = this._text;\n    return node;\n  }\n};\nvar VNodeQuery = class extends VNode {\n  getElementById(name) {\n    return this.flatten().find(e => e._attributes[\"id\"] === name);\n  }\n  getElementsByClassName(name) {\n    return this.flatten().filter(e => e.classList.contains(name));\n  }\n  matches(selector) {\n    return matchSelector(selector, this);\n  }\n  querySelectorAll(selector) {\n    return this.flatten().filter(e => e.matches(selector));\n  }\n  querySelector(selector) {\n    return this.flatten().find(e => e.matches(selector));\n  }\n  parent(selector) {\n    var _a;\n    if (this.matches(selector)) {\n      return this;\n    }\n    if (this.parentNode == null) {\n      return null;\n    }\n    return (_a = this.parentNode) == null ? void 0 : _a.parent(selector);\n  }\n  handle(selector, handler) {\n    let i = 0;\n    for (let el of this.querySelectorAll(selector)) {\n      handler(el, i++);\n    }\n  }\n};\nvar VElement = class extends VNodeQuery {\n  constructor(name = \"div\", attrs = {}) {\n    super();\n    this._originalTagName = name;\n    this._nodeName = (name || \"\").toUpperCase();\n    this._attributes = attrs || {};\n    this._styles = null;\n  }\n  get nodeType() {\n    return VNode.ELEMENT_NODE;\n  }\n  get nodeName() {\n    return this._nodeName;\n  }\n  cloneNode(deep = false) {\n    let node = super.cloneNode(deep);\n    node._originalTagName = this._originalTagName;\n    node._nodeName = this._nodeName;\n    node._attributes = Object.assign({}, this._attributes);\n    return node;\n  }\n  get attributes() {\n    return this._attributes;\n  }\n  _findAttributeName(name) {\n    const search = name.toLowerCase();\n    return Object.keys(this._attributes).find(name2 => search === name2.toLowerCase()) || null;\n  }\n  setAttribute(name, value) {\n    this.removeAttribute(name);\n    this._attributes[name] = value;\n    this._styles = null;\n  }\n  getAttribute(name) {\n    const originalName = this._findAttributeName(name);\n    return originalName ? this._attributes[originalName] : null;\n  }\n  removeAttribute(name) {\n    const originalName = this._findAttributeName(String(name));\n    if (originalName) {\n      delete this._attributes[name];\n    }\n  }\n  hasAttribute(name) {\n    const originalName = this._findAttributeName(name);\n    return originalName ? this._attributes[originalName] != null : false;\n  }\n  get style() {\n    if (this._styles == null) {\n      let styles = Object.assign({}, DEFAULTS[this.tagName.toLowerCase()] || {});\n      let styleString = this.getAttribute(\"style\");\n      if (styleString) {\n        let m;\n        let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g;\n        while (m = re.exec(styleString)) {\n          let name = m[1];\n          let value = m[2].trim();\n          styles[name] = value;\n          styles[toCamelCase(name)] = value;\n        }\n      }\n      this._styles = styles;\n    }\n    return this._styles;\n  }\n  get tagName() {\n    return this._nodeName;\n  }\n  get id() {\n    return this._attributes.id || null;\n  }\n  set id(value) {\n    if (value == null) delete this._attributes.id;else this._attributes.id = value;\n  }\n  get src() {\n    return this._attributes.src;\n  }\n  set src(value) {\n    if (value == null) delete this._attributes.src;else this._attributes.src = value;\n  }\n  getElementsByTagName(name) {\n    name = name.toUpperCase();\n    let elements = this.flatten();\n    if (name !== \"*\") {\n      return elements.filter(e => e.tagName === name);\n    }\n    return elements;\n  }\n  setInnerHTML(html2) {\n    throw \"setInnerHTML is not implemented; see vdomparser for an example\";\n  }\n  get innerHTML() {\n    return this._childNodes.map(c => c.render(html)).join(\"\");\n  }\n  set innerHTML(html2) {\n    this.setInnerHTML(html2);\n  }\n  get outerHTML() {\n    return this.render(htmlVDOM);\n  }\n  get className() {\n    return this._attributes[\"class\"] || \"\";\n  }\n  set className(name) {\n    if (Array.isArray(name)) {\n      name = name.filter(n => !!n).join(\" \");\n    } else if (typeof name === \"object\") {\n      name = Object.entries(name).filter(([k, v]) => !!v).map(([k, v]) => k).join(\" \");\n    }\n    this._attributes[\"class\"] = name;\n  }\n  get classList() {\n    let self = this;\n    let classNames = (this.className || \"\").trim().split(/\\s+/g) || [];\n    return {\n      contains(s) {\n        return classNames.includes(s);\n      },\n      add(s) {\n        if (!classNames.includes(s)) {\n          classNames.push(s);\n          self.className = classNames;\n        }\n      },\n      remove(s) {\n        let index = classNames.indexOf(s);\n        if (index >= 0) {\n          classNames.splice(index, 1);\n          self.className = classNames;\n        }\n      }\n    };\n  }\n  render(h2 = htmlVDOM) {\n    return h2(this._originalTagName || this.tagName, this.attributes, this._childNodes.map(c => c.render(h2)).join(\"\"));\n  }\n};\nvar VDocType = class extends VNode {\n  get nodeName() {\n    return super.nodeName;\n  }\n  get nodeValue() {\n    return super.nodeValue;\n  }\n  get nodeType() {\n    return VDocType.DOCUMENT_TYPE_NODE;\n  }\n  render() {\n    return `<!DOCTYPE html>`;\n  }\n};\nvar VDocumentFragment = class extends VNodeQuery {\n  get nodeType() {\n    return VNode.DOCUMENT_FRAGMENT_NODE;\n  }\n  get nodeName() {\n    return \"#document-fragment\";\n  }\n  render(h2 = htmlVDOM) {\n    return this._childNodes.map(c => c.render(h2) || []).join(\"\");\n  }\n  get innerHTML() {\n    return this._childNodes.map(c => c.render(html)).join(\"\");\n  }\n  createElement(name, attrs = {}) {\n    return new VElement(name, attrs);\n  }\n  createDocumentFragment() {\n    return new VDocumentFragment();\n  }\n  createTextNode(text) {\n    return new VTextNode(text);\n  }\n};\nvar VDocument = class extends VDocumentFragment {\n  get nodeType() {\n    return VNode.DOCUMENT_NODE;\n  }\n  get nodeName() {\n    return \"#document\";\n  }\n  get documentElement() {\n    return this.firstChild;\n  }\n  render(h2 = htmlVDOM) {\n    let content = super.render(h2);\n    if (this.docType) {\n      content = this.docType.render() + content;\n    }\n    return content;\n  }\n};\nvar VHTMLDocument = class extends VDocument {\n  constructor(empty = false) {\n    super();\n    this.docType = new VDocType();\n    if (!empty) {\n      let html2 = new VElement(\"html\");\n      let body = new VElement(\"body\");\n      let head = new VElement(\"head\");\n      let title = new VElement(\"title\");\n      html2.appendChild(head);\n      head.appendChild(title);\n      html2.appendChild(body);\n      this.appendChild(html2);\n    }\n  }\n  get body() {\n    let body = this.querySelector(\"body\");\n    if (!body) {\n      let html2 = this.querySelector(\"html\");\n      if (!html2) {\n        html2 = new VElement(\"html\");\n        this.appendChild(html2);\n      }\n      body = new VElement(\"body\");\n      html2.appendChild(html2);\n    }\n    return body;\n  }\n  get title() {\n    var _a;\n    return ((_a = this.querySelector(\"title\")) == null ? void 0 : _a.textContent) || \"\";\n  }\n  set title(title) {\n    const titleElement = this.querySelector(\"title\");\n    if (titleElement) titleElement.textContent = title;\n  }\n  get head() {\n    let head = this.querySelector(\"head\");\n    if (!head) {\n      let html2 = this.querySelector(\"html\");\n      if (!html2) {\n        html2 = new VElement(\"html\");\n        this.appendChild(html2);\n      }\n      head = new VElement(\"head\");\n      html2.insertBefore(html2);\n    }\n    return head;\n  }\n};\nfunction createDocument() {\n  return new VDocument();\n}\nfunction createHTMLDocument() {\n  return new VHTMLDocument();\n}\nvar document = createDocument();\nvar h = hFactory({\n  document\n});\n\n// src/utils.ts\nfunction removeBodyContainer(body) {\n  let ehead = body.querySelector(\"head\");\n  let ebody = body.querySelector(\"body\");\n  if (ebody || ehead) {\n    let body2 = new VDocumentFragment();\n    ehead && body2.appendChild(ehead.childNodes);\n    ebody && body2.appendChild(ebody.children);\n    return body2;\n  }\n  return body;\n}\n\n// src/htmlparser.ts\nvar attrRe = /([^=\\s]+)(\\s*=\\s*((\"([^\"]*)\")|('([^']*)')|[^>\\s]+))?/gm;\nvar endTagRe = /^<\\/([^>\\s]+)[^>]*>/m;\nvar startTagRe = /^<([^>\\s\\/]+)((\\s+[^=>\\s]+(\\s*=\\s*((\"[^\"]*\")|('[^']*')|[^>\\s]+))?)*)\\s*\\/?\\s*>/m;\nvar selfCloseTagRe = /\\s*\\/\\s*>\\s*$/m;\nvar HtmlParser = class {\n  constructor(options) {\n    this.attrRe = attrRe;\n    this.endTagRe = endTagRe;\n    this.startTagRe = startTagRe;\n    this.defaults = {\n      ignoreWhitespaceText: false\n    };\n    options = options || {};\n    if (options.scanner) {\n      this.scanner = options.scanner;\n      options.scanner = null;\n    }\n    this.options = Object.assign({}, this.defaults, options);\n  }\n  parse(html2) {\n    let treatAsChars = false;\n    let index, match, characters;\n    while (html2.length) {\n      if (html2.substring(0, 4) === \"<!--\") {\n        index = html2.indexOf(\"-->\");\n        if (index !== -1) {\n          this.scanner.comment(html2.substring(4, index));\n          html2 = html2.substring(index + 3);\n          treatAsChars = false;\n        } else {\n          treatAsChars = true;\n        }\n      } else if (html2.substring(0, 2) === \"</\") {\n        match = this.endTagRe.exec(html2);\n        if (match) {\n          html2 = RegExp.rightContext;\n          treatAsChars = false;\n          this.parseEndTag(RegExp.lastMatch, match[1]);\n        } else {\n          treatAsChars = true;\n        }\n      } else if (html2.charAt(0) === \"<\") {\n        match = this.startTagRe.exec(html2);\n        if (match) {\n          html2 = RegExp.rightContext;\n          treatAsChars = false;\n          this.parseStartTag(RegExp.lastMatch, match[1], match);\n        } else {\n          treatAsChars = true;\n        }\n      }\n      if (treatAsChars) {\n        index = html2.indexOf(\"<\");\n        if (index === 0) {\n          index = html2.substring(1).indexOf(\"<\");\n        }\n        if (index === -1) {\n          characters = html2;\n          html2 = \"\";\n        } else {\n          characters = html2.substring(0, index);\n          html2 = html2.substring(index);\n        }\n        if (!this.options.ignoreWhitespaceText || !/^\\s*$/.test(characters)) {\n          this.scanner.characters(characters);\n        }\n      }\n      treatAsChars = true;\n      match = null;\n    }\n  }\n  parseStartTag(input, tagName, match) {\n    const isSelfColse = selfCloseTagRe.test(input);\n    let attrInput = match[2];\n    if (isSelfColse) {\n      attrInput = attrInput.replace(/\\s*\\/\\s*$/, \"\");\n    }\n    const attrs = this.parseAttributes(tagName, attrInput);\n    this.scanner.startElement(tagName, attrs, isSelfColse, match[0]);\n  }\n  parseEndTag(input, tagName) {\n    this.scanner.endElement(tagName);\n  }\n  parseAttributes(tagName, input) {\n    const attrs = {};\n    input.replace(this.attrRe, (attr, name, c2, value, c4, valueInQuote, c6, valueInSingleQuote) => {\n      attrs[name] = valueInSingleQuote ?? valueInQuote ?? value ?? true;\n    });\n    return attrs;\n  }\n};\n\n// src/vdomparser.ts\nfunction vdom(obj = null) {\n  if (obj instanceof VNode) {\n    return obj;\n  }\n  if (obj instanceof Buffer) {\n    obj = obj.toString(\"utf-8\");\n  }\n  if (typeof obj === \"string\") {\n    return parseHTML(obj);\n  }\n  return new VDocumentFragment();\n}\nfunction parseHTML(html2) {\n  if (typeof html2 !== \"string\") {\n    console.error(\"parseHTML requires string, found\", html2);\n    throw new Error(\"parseHTML requires string\");\n  }\n  let frag = html2.indexOf(\"<!\") === 0 ? new VHTMLDocument(true) : new VDocumentFragment();\n  let stack = [frag];\n  let parser = new HtmlParser({\n    scanner: {\n      startElement(tagName, attrs, isSelfClosing) {\n        const lowerTagName = tagName.toLowerCase();\n        if (lowerTagName === \"!doctype\") {\n          frag.docType = new VDocType();\n          return;\n        }\n        for (let name in attrs) {\n          if (attrs.hasOwnProperty(name)) {\n            let value = attrs[name];\n            if (typeof value === \"string\") {\n              attrs[name] = unescapeHTML(value);\n            }\n          }\n        }\n        let parentNode = stack[stack.length - 1];\n        if (parentNode) {\n          const element = document.createElement(tagName, attrs);\n          parentNode.appendChild(element);\n          if (!(SELF_CLOSING_TAGS.includes(tagName.toLowerCase()) || isSelfClosing)) {\n            stack.push(element);\n          }\n        }\n      },\n      endElement(tagName) {\n        stack.pop();\n      },\n      characters(text) {\n        var _a;\n        text = unescapeHTML(text);\n        let parentNode = stack[stack.length - 1];\n        if (((_a = parentNode == null ? void 0 : parentNode.lastChild) == null ? void 0 : _a.nodeType) === VNode.TEXT_NODE) {\n          parentNode.lastChild._text += text;\n        } else {\n          if (parentNode) {\n            parentNode.appendChild(new VTextNode(text));\n          }\n        }\n      },\n      comment(text) {}\n    }\n  });\n  parser.parse(html2);\n  return frag;\n}\nVElement.prototype.setInnerHTML = function (html2) {\n  let frag = parseHTML(html2);\n  this._childNodes = frag._childNodes;\n  this._fixChildNodesParent();\n};\n\n// src/tidy.ts\nvar SELECTOR_BLOCK_ELEMENTS = \"meta,link,script,p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,head,body,title,nav,section,article,hr,form\";\nvar TAGS_KEEP_CONTENT = [\"PRE\", \"CODE\", \"SCRIPT\", \"STYLE\", \"TT\"];\nfunction level(element) {\n  let indent = \"\";\n  while (element.parentNode) {\n    indent += \"  \";\n    element = element.parentNode;\n  }\n  return indent.substr(2);\n}\nfunction tidyDOM(document2) {\n  document2.handle(SELECTOR_BLOCK_ELEMENTS, e => {\n    var _a, _b, _c, _d, _e, _f;\n    let ee = e;\n    while (ee) {\n      if (TAGS_KEEP_CONTENT.includes(ee.tagName)) return;\n      ee = ee.parentNode;\n    }\n    let prev = e.previousSibling;\n    if (!prev || prev.nodeType !== VNode.TEXT_NODE || !((_a = prev.nodeValue) == null ? void 0 : _a.endsWith(\"\\n\"))) {\n      (_b = e.parentNode) == null ? void 0 : _b.insertBefore(new VTextNode(\"\\n\"), e);\n    }\n    (_c = e.parentNode) == null ? void 0 : _c.insertBefore(new VTextNode(level(e)), e);\n    let next = e.nextSibling;\n    if (!next || next.nodeType !== VNode.TEXT_NODE || !((_d = next.nodeValue) == null ? void 0 : _d.startsWith(\"\\n\"))) {\n      if (next) {\n        (_e = e.parentNode) == null ? void 0 : _e.insertBefore(new VTextNode(\"\\n\"), next);\n      } else {\n        (_f = e.parentNode) == null ? void 0 : _f.appendChild(new VTextNode(\"\\n\"));\n      }\n    }\n    if (e.childNodes.length) {\n      let first = e.firstChild;\n      if (first.nodeType === VNode.TEXT_NODE) {\n        e.insertBefore(new VTextNode(\"\\n\" + level(e) + \"  \"));\n      }\n      e.appendChild(new VTextNode(\"\\n\" + level(e)));\n    }\n  });\n}\n\n// src/xml.ts\nfunction xml(itag, iattrs, ...ichildren) {\n  let {\n    tag,\n    attrs,\n    children\n  } = hArgumentParser(itag, iattrs, ichildren);\n  return markup(true, tag, attrs, children);\n}\nxml.firstLine = '<?xml version=\"1.0\" encoding=\"utf-8\"?>';\nxml.xml = true;\nexport { CDATA, VDocType, VDocument, VDocumentFragment, VElement, VHTMLDocument, VNode, VNodeQuery, VTextNode, createDocument, createHTMLDocument, document, escapeHTML, h, hArgumentParser, hFactory, html, parseHTML, removeBodyContainer, tidyDOM, unescapeHTML, vdom, xml };","map":{"version":3,"names":["parse","cache","parseSelector","selector","ast","matchSelector","element","debug","rules","console","log","handleRules","element2","rules2","_a","_b","_c","success","part","type","name","action","value","ignoreCase","data","getAttribute","startsWith","endsWith","classList","contains","includes","hasAttribute","warn","tagName","toUpperCase","ok","forEach","rules3","inspect","Symbol","for","B","fontWeight","I","fontStyle","M","backgroundColor","U","textDecorations","S","DEFAULTS","b","strong","em","i","mark","u","a","s","del","ins","strike","toCamelCase","toLowerCase","replace","m","chr","_VNode","constructor","append","appendChild","_parentNode","_childNodes","nodeType","error","nodeName","nodeValue","cloneNode","deep","node","map","c","_fixChildNodesParent","insertBefore","newNode","index","indexOf","splice","VDocument","VDocumentFragment","Array","isArray","remove","push","text","JSON","stringify","VTextNode","err","render","removeChild","parentNode","replaceChildren","nodes","n","replaceWith","p","_indexInParent","childNodes","children","firstChild","lastChild","length","nextSibling","previousSibling","flatten","elements","VElement","child","flattenNodes","textContent","join","toString","otherNode","some","ownerDocument","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","VNode","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_TYPE_NODE","_text","parentTagName","escapeHTML","VNodeQuery","getElementById","find","e","_attributes","getElementsByClassName","filter","matches","querySelectorAll","querySelector","parent","handle","handler","el","attrs","_originalTagName","_nodeName","_styles","Object","assign","attributes","_findAttributeName","search","keys","name2","setAttribute","removeAttribute","originalName","String","style","styles","styleString","re","exec","trim","id","src","getElementsByTagName","setInnerHTML","html2","innerHTML","html","outerHTML","htmlVDOM","className","entries","k","v","self","classNames","split","add","h2","VDocType","createElement","createDocumentFragment","createTextNode","documentElement","content","docType","VHTMLDocument","empty","body","head","title","titleElement","createDocument","createHTMLDocument","document","h","hFactory","removeBodyContainer","ehead","ebody","body2","attrRe","endTagRe","startTagRe","selfCloseTagRe","HtmlParser","options","defaults","ignoreWhitespaceText","scanner","treatAsChars","match","characters","substring","comment","RegExp","rightContext","parseEndTag","lastMatch","charAt","parseStartTag","test","input","isSelfColse","attrInput","parseAttributes","startElement","endElement","attr","c2","c4","valueInQuote","c6","valueInSingleQuote","vdom","obj","Buffer","parseHTML","Error","frag","stack","parser","isSelfClosing","lowerTagName","hasOwnProperty","unescapeHTML","SELF_CLOSING_TAGS","pop","prototype","SELECTOR_BLOCK_ELEMENTS","TAGS_KEEP_CONTENT","level","indent","substr","tidyDOM","document2","_d","_e","_f","ee","prev","next","first","xml","itag","iattrs","ichildren","tag","hArgumentParser","markup","firstLine"],"sources":["C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\vcss.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\vdom.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\utils.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\htmlparser.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\vdomparser.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\tidy.ts","C:\\Users\\moral\\Desktop\\Capstone Project JAR\\JAR\\node_modules\\zeed-dom\\src\\xml.ts"],"sourcesContent":["// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { parse } from \"css-what\"\nimport { VElement } from \"./vdom\"\n\n// Alternative could be https://github.com/leaverou/parsel\n\nlet cache = {}\n\nexport function parseSelector(selector: string) {\n  let ast = cache[selector]\n  if (ast == null) {\n    ast = parse(selector)\n    cache[selector] = ast\n  }\n  return ast\n}\n\n// Just a very small subset for now: https://github.com/fb55/css-what#api\n\nexport function matchSelector(\n  selector: string,\n  element: VElement,\n  { debug = false } = {}\n) {\n  for (let rules of parseSelector(selector)) {\n    if (debug) {\n      console.log(\"Selector:\", selector)\n      console.log(\"Rules:\", rules)\n      console.log(\"Element:\", element)\n    }\n\n    const handleRules = (element: VElement, rules: any[]) => {\n      let success: boolean = false\n      for (let part of rules) {\n        const { type, name, action, value, ignoreCase = true, data } = part\n        if (type === \"attribute\") {\n          if (action === \"equals\") {\n            success = element.getAttribute(name) === value\n            if (debug) console.log(\"Attribute equals\", success)\n          } else if (action === \"start\") {\n            success = !!element.getAttribute(name)?.startsWith(value)\n            if (debug) console.log(\"Attribute start\", success)\n          } else if (action === \"end\") {\n            success = !!element.getAttribute(name)?.endsWith(value)\n            if (debug) console.log(\"Attribute start\", success)\n          } else if (action === \"element\") {\n            if (name === \"class\") {\n              success = element.classList.contains(value)\n              if (debug) console.log(\"Attribute class\", success)\n            } else {\n              success = !!element.getAttribute(name)?.includes(value)\n              if (debug) console.log(\"Attribute element\", success)\n            }\n          } else if (action === \"exists\") {\n            success = element.hasAttribute(name)\n            if (debug) console.log(\"Attribute exists\", success)\n          } else {\n            console.warn(\"Unknown CSS selector action\", action)\n          }\n        } else if (type === \"tag\") {\n          success = element.tagName === name.toUpperCase()\n          if (debug) console.log(\"Is tag\", success)\n        } else if (type === \"universal\") {\n          success = true\n          if (debug) console.log(\"Is universal\", success)\n        } else if (type === \"pseudo\") {\n          if (name === \"not\") {\n            let ok = true\n            data.forEach((rules) => {\n              if (!handleRules(element, rules)) {\n                ok = false\n              }\n            })\n            success = !ok\n          }\n          if (debug) console.log(\"Is :not\", success)\n          // } else if (type === 'descendant') {\n          //   element = element.\n        } else {\n          console.warn(\"Unknown CSS selector type\", type, selector, rules)\n        }\n        // console.log(success, selector, part, element)\n        if (!success) break\n      }\n      return success\n    }\n\n    if (handleRules(element, rules)) {\n      return true\n    }\n  }\n  return false\n}\n","// Copyright (c) 2020 Dirk Holtwick. All rights reserved. https://holtwick.de/copyright\n\nimport { escapeHTML } from \"./encoding\"\nimport { hFactory } from \"./h\"\nimport { html, htmlVDOM } from \"./html\"\nimport { matchSelector } from \"./vcss\"\n\n// For node debugging\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\")\n\nlet B = { fontWeight: \"bold\" }\nlet I = { fontStyle: \"italic\" }\nlet M = { backgroundColor: \"rgb(255, 250, 165)\" }\nlet U = { textDecorations: \"underline\" }\nlet S = { textDecorations: \"line-through\" }\n// let C = {}\n\nlet DEFAULTS = {\n  b: B,\n  strong: B,\n  em: I,\n  i: I,\n  mark: M,\n  u: U,\n  a: U,\n  s: S,\n  del: S,\n  ins: M,\n  strike: S,\n  // 'code': C,\n  // 'tt': C\n}\n\nlet toCamelCase = (s: string) =>\n  s.toLowerCase().replace(/[^a-zA-Z0-9]+(.)/g, (m, chr) => chr.toUpperCase())\n\nexport class VNode {\n  static ELEMENT_NODE = 1\n  static TEXT_NODE = 3\n  static CDATA_SECTION_NODE = 4\n  static PROCESSING_INSTRUCTION_NODE = 7\n  static COMMENT_NODE = 8\n  static DOCUMENT_NODE = 9\n  static DOCUMENT_TYPE_NODE = 10\n  static DOCUMENT_FRAGMENT_NODE = 11\n\n  _parentNode: any\n  _childNodes: any[]\n\n  get nodeType(): number {\n    console.error(\"Subclasses should define nodeType!\")\n    return 0\n  }\n\n  get nodeName() {\n    console.error(\"Subclasses should define nodeName!\")\n    return \"\"\n  }\n\n  get nodeValue(): string | null {\n    return null\n  }\n\n  constructor() {\n    this._parentNode = null\n    this._childNodes = []\n  }\n\n  cloneNode(deep = false) {\n    // @ts-ignore\n    let node = new this.constructor()\n    if (deep) {\n      node._childNodes = this._childNodes.map((c) => c.cloneNode(true))\n      node._fixChildNodesParent()\n    }\n    return node\n  }\n\n  _fixChildNodesParent() {\n    this._childNodes.forEach((node) => (node._parentNode = this))\n  }\n\n  insertBefore(newNode: VNode, node?: VNode) {\n    if (newNode !== node) {\n      let index = node ? this._childNodes.indexOf(node) : 0\n      if (index < 0) index = 0\n      this._childNodes.splice(index, 0, newNode)\n      this._fixChildNodesParent()\n    }\n  }\n\n  appendChild(node: VNode | VNode[] | string | string[] | null | undefined) {\n    if (node == null) return\n    if (node === this) {\n      console.warn(\"Cannot appendChild to self\")\n      return\n    }\n    // log('appendChild', node, this)\n\n    if (node instanceof VDocument) {\n      console.warn(\"No defined how to append a document to a node!\", node)\n    }\n\n    if (node instanceof VDocumentFragment) {\n      for (let c of [...node._childNodes]) {\n        // Don't iterate over the original! Do [...el]\n        this.appendChild(c)\n      }\n    } else if (Array.isArray(node)) {\n      for (let c of [...node]) {\n        // Don't iterate over the original! Do [...el]\n        this.appendChild(c)\n      }\n    } else if (node instanceof VNode) {\n      node.remove()\n      this._childNodes.push(node)\n    } else {\n      // Fallback for unknown data\n      try {\n        const text =\n          typeof node === \"string\" ? node : JSON.stringify(node, null, 2)\n        this._childNodes.push(new VTextNode(text))\n      } catch (err) {\n        console.error(\n          `The data ${node} to be added to ${this.render()} is problematic: ${err}`\n        )\n      }\n    }\n    this._fixChildNodesParent()\n  }\n\n  append = this.appendChild\n\n  removeChild(node: { _parentNode: null }) {\n    let i = this._childNodes.indexOf(node)\n    if (i >= 0) {\n      node._parentNode = null\n      this._childNodes.splice(i, 1)\n      this._fixChildNodesParent()\n    }\n  }\n\n  remove() {\n    this?.parentNode?.removeChild(this)\n    return this\n  }\n\n  replaceChildren(...nodes: any[]) {\n    this._childNodes = nodes.map((n) =>\n      typeof n === \"string\" ? new VTextNode(n) : n.remove()\n    )\n    this._fixChildNodesParent()\n  }\n\n  replaceWith(...nodes: any[]) {\n    let p = this._parentNode\n    if (p) {\n      let index = this._indexInParent()\n      if (index >= 0) {\n        nodes = nodes.map((n) =>\n          typeof n === \"string\" ? new VTextNode(n) : n.remove()\n        )\n        p._childNodes.splice(index, 1, ...nodes)\n        this._parentNode = null\n        p._fixChildNodesParent()\n      }\n    }\n  }\n\n  _indexInParent() {\n    if (this._parentNode) {\n      return this._parentNode.childNodes.indexOf(this)\n    }\n    return -1\n  }\n\n  get parentNode() {\n    return this._parentNode\n  }\n\n  get childNodes() {\n    return this._childNodes || []\n  }\n\n  get children() {\n    return this._childNodes || []\n  }\n\n  get firstChild() {\n    return this._childNodes[0]\n  }\n\n  get lastChild() {\n    return this._childNodes[this._childNodes.length - 1]\n  }\n\n  get nextSibling() {\n    let i = this._indexInParent()\n    if (i != null) {\n      return this.parentNode.childNodes[i + 1] || null\n    }\n    return null\n  }\n\n  get previousSibling() {\n    let i = this._indexInParent()\n    if (i > 0) {\n      return this.parentNode.childNodes[i - 1] || null\n    }\n    return null\n  }\n\n  flatten(): VElement[] {\n    let elements: VElement[] = []\n    if (this instanceof VElement) {\n      elements.push(this)\n    }\n    for (let child of this._childNodes) {\n      elements.push(...child.flatten())\n    }\n    return elements\n  }\n\n  flattenNodes(): VNode[] {\n    let nodes: VNode[] = []\n    nodes.push(this)\n    for (let child of this._childNodes) {\n      nodes.push(...child.flattenNodes())\n    }\n    return nodes\n  }\n\n  render() {\n    return \"\"\n  }\n\n  get textContent(): string | null {\n    return this._childNodes.map((c) => c.textContent).join(\"\")\n  }\n\n  set textContent(text) {\n    this._childNodes = []\n    if (text) {\n      this.appendChild(new VTextNode(text.toString()))\n    }\n  }\n\n  contains(otherNode: this) {\n    if (otherNode === this) return true\n    // if (this._childNodes.includes(otherNode)) return true\n    return this._childNodes.some((n) => n.contains(otherNode))\n  }\n\n  get ownerDocument() {\n    if (\n      this.nodeType === VNode.DOCUMENT_NODE ||\n      this.nodeType === VNode.DOCUMENT_FRAGMENT_NODE\n    ) {\n      return this\n    }\n    return this?._parentNode?.ownerDocument\n  }\n\n  toString(): string {\n    return `${this.nodeName}`\n    // return `${this.nodeName}: ${JSON.stringify(this.nodeValue)}`\n  }\n\n  [inspect]() {\n    return `${this.constructor.name} \"${this.render()}\"`\n  }\n}\n\nexport class VTextNode extends VNode {\n  _text: string\n\n  get nodeType(): number {\n    return VNode.TEXT_NODE\n  }\n\n  get nodeName() {\n    return \"#text\"\n  }\n\n  get nodeValue(): string | null {\n    return this._text || \"\"\n  }\n\n  get textContent(): string | null {\n    return this.nodeValue\n  }\n\n  constructor(text = \"\") {\n    super()\n    this._text = text\n  }\n\n  render() {\n    const parentTagName = this.parentNode?.tagName\n    if (parentTagName === \"SCRIPT\" || parentTagName === \"STYLE\") {\n      return this._text\n    }\n    return escapeHTML(this._text)\n  }\n\n  cloneNode(deep = false) {\n    let node = super.cloneNode(deep)\n    node._text = this._text\n    return node\n  }\n}\n\nexport class VNodeQuery extends VNode {\n  getElementById(name: string) {\n    return this.flatten().find((e) => e._attributes[\"id\"] === name)\n  }\n\n  getElementsByClassName(name: any) {\n    return this.flatten().filter((e) => e.classList.contains(name))\n  }\n\n  matches(selector: string) {\n    return matchSelector(selector, this as any)\n  }\n\n  querySelectorAll(selector: any) {\n    return this.flatten().filter((e) => e.matches(selector))\n  }\n\n  querySelector(selector: string) {\n    return this.flatten().find((e) => e.matches(selector))\n  }\n\n  //\n\n  parent(selector: string) {\n    if (this.matches(selector)) {\n      return this\n    }\n    if (this.parentNode == null) {\n      return null\n    }\n    return this.parentNode?.parent(selector)\n  }\n\n  handle(selector: any, handler: (arg0: VElement, arg1: number) => void) {\n    let i = 0\n    for (let el of this.querySelectorAll(selector)) {\n      handler(el, i++)\n    }\n  }\n}\n\nexport class VElement extends VNodeQuery {\n  _originalTagName: string\n  _nodeName: any\n  _attributes: Record<string, string>\n  _styles: any\n\n  get nodeType() {\n    return VNode.ELEMENT_NODE\n  }\n\n  get nodeName() {\n    return this._nodeName\n  }\n\n  constructor(name = \"div\", attrs = {}) {\n    super()\n    this._originalTagName = name\n    this._nodeName = (name || \"\").toUpperCase()\n    this._attributes = attrs || {}\n    this._styles = null\n  }\n\n  cloneNode(deep = false) {\n    let node = super.cloneNode(deep)\n    node._originalTagName = this._originalTagName\n    node._nodeName = this._nodeName\n    node._attributes = Object.assign({}, this._attributes)\n    return node\n  }\n\n  get attributes() {\n    return this._attributes\n  }\n\n  _findAttributeName(name: string) {\n    const search = name.toLowerCase()\n    return (\n      Object.keys(this._attributes).find(\n        (name) => search === name.toLowerCase()\n      ) || null\n    )\n  }\n\n  setAttribute(name: string, value: string) {\n    this.removeAttribute(name)\n    this._attributes[name] = value\n    this._styles = null\n  }\n\n  getAttribute(name: string): string | null {\n    const originalName = this._findAttributeName(name)\n    return originalName ? this._attributes[originalName] : null\n  }\n\n  removeAttribute(name: string | number) {\n    const originalName = this._findAttributeName(String(name))\n    if (originalName) {\n      delete this._attributes[name]\n    }\n  }\n\n  hasAttribute(name: any) {\n    const originalName = this._findAttributeName(name)\n    return originalName ? this._attributes[originalName] != null : false\n  }\n\n  get style() {\n    if (this._styles == null) {\n      let styles = Object.assign({}, DEFAULTS[this.tagName.toLowerCase()] || {})\n      let styleString = this.getAttribute(\"style\")\n      if (styleString) {\n        let m: string[] | null\n        let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g\n        while ((m = re.exec(styleString))) {\n          let name = m[1]\n          let value = m[2].trim()\n          styles[name] = value\n          styles[toCamelCase(name)] = value\n        }\n      }\n      this._styles = styles\n    }\n    return this._styles\n  }\n\n  get tagName() {\n    return this._nodeName\n  }\n\n  get id(): string | null {\n    return this._attributes.id || null\n  }\n\n  set id(value: string | null) {\n    if (value == null) delete this._attributes.id\n    else this._attributes.id = value\n  }\n\n  get src(): string | null {\n    return this._attributes.src\n  }\n\n  set src(value: string | null) {\n    if (value == null) delete this._attributes.src\n    else this._attributes.src = value\n  }\n\n  //\n\n  getElementsByTagName(name: string) {\n    name = name.toUpperCase()\n    let elements = this.flatten()\n    if (name !== \"*\") {\n      return elements.filter((e) => e.tagName === name)\n    }\n    return elements\n  }\n\n  // html\n\n  setInnerHTML(html: string) {\n    throw \"setInnerHTML is not implemented; see vdomparser for an example\"\n  }\n\n  get innerHTML() {\n    return this._childNodes.map((c) => c.render(html)).join(\"\")\n  }\n\n  set innerHTML(html) {\n    this.setInnerHTML(html)\n  }\n\n  get outerHTML() {\n    return this.render(htmlVDOM)\n  }\n\n  // class\n\n  get className(): string {\n    return this._attributes[\"class\"] || \"\"\n  }\n\n  set className(name: string | string[]) {\n    if (Array.isArray(name)) {\n      name = name.filter((n) => !!n).join(\" \")\n    } else if (typeof name === \"object\") {\n      name = Object.entries(name)\n        .filter(([k, v]) => !!v)\n        .map(([k, v]) => k)\n        .join(\" \")\n    }\n    this._attributes[\"class\"] = name\n  }\n\n  get classList() {\n    let self = this\n    let classNames = (this.className || \"\").trim().split(/\\s+/g) || []\n    // log('classList', classNames)\n    return {\n      contains(s: any) {\n        return classNames.includes(s)\n      },\n      add(s: any) {\n        if (!classNames.includes(s)) {\n          classNames.push(s)\n          self.className = classNames\n        }\n      },\n      remove(s: any) {\n        let index = classNames.indexOf(s)\n        if (index >= 0) {\n          classNames.splice(index, 1)\n          self.className = classNames\n        }\n      },\n    }\n  }\n\n  //\n\n  render(h = htmlVDOM) {\n    return h(\n      this._originalTagName || this.tagName,\n      this.attributes,\n      this._childNodes.map((c) => c.render(h)).join(\"\") // children:string is not escaped again\n    )\n  }\n}\n\nexport class VDocType extends VNode {\n  //todo\n\n  name: any\n  publicId: any\n  systemId: any\n\n  get nodeName(): string {\n    return super.nodeName\n  }\n\n  get nodeValue(): string | null {\n    return super.nodeValue\n  }\n\n  get nodeType(): number {\n    return VDocType.DOCUMENT_TYPE_NODE\n  }\n\n  render() {\n    return `<!DOCTYPE html>` // hack!\n  }\n}\n\nexport class VDocumentFragment extends VNodeQuery {\n  docType: VDocType\n\n  get nodeType() {\n    return VNode.DOCUMENT_FRAGMENT_NODE\n  }\n\n  get nodeName() {\n    return \"#document-fragment\"\n  }\n\n  render(h = htmlVDOM) {\n    return this._childNodes.map((c) => c.render(h) || []).join(\"\")\n  }\n\n  get innerHTML() {\n    // for debug\n    return this._childNodes.map((c) => c.render(html)).join(\"\")\n  }\n\n  createElement(name: string, attrs = {}) {\n    return new VElement(name, attrs)\n  }\n\n  createDocumentFragment() {\n    return new VDocumentFragment()\n  }\n\n  createTextNode(text?: string) {\n    return new VTextNode(text)\n  }\n}\n\nexport class VDocument extends VDocumentFragment {\n  get nodeType() {\n    return VNode.DOCUMENT_NODE\n  }\n\n  get nodeName() {\n    return \"#document\"\n  }\n\n  get documentElement() {\n    return this.firstChild\n  }\n\n  render(h = htmlVDOM) {\n    let content = super.render(h)\n    if (this.docType) {\n      content = this.docType.render() + content\n    }\n    return content\n  }\n}\n\nexport class VHTMLDocument extends VDocument {\n  constructor(empty: boolean = false) {\n    super()\n    this.docType = new VDocType()\n    if (!empty) {\n      let html = new VElement(\"html\")\n      let body = new VElement(\"body\")\n      let head = new VElement(\"head\")\n      let title = new VElement(\"title\")\n      html.appendChild(head)\n      head.appendChild(title)\n      html.appendChild(body)\n      this.appendChild(html)\n    }\n  }\n\n  get body(): VElement {\n    let body = this.querySelector(\"body\")\n    if (!body) {\n      let html = this.querySelector(\"html\")\n      if (!html) {\n        html = new VElement(\"html\")\n        this.appendChild(html)\n      }\n      body = new VElement(\"body\")\n      html.appendChild(html)\n    }\n    return body\n  }\n\n  get title(): string {\n    return this.querySelector(\"title\")?.textContent || \"\"\n  }\n\n  set title(title: string) {\n    const titleElement = this.querySelector(\"title\")\n    if (titleElement) titleElement.textContent = title\n  }\n\n  get head(): VElement {\n    let head = this.querySelector(\"head\")\n    if (!head) {\n      let html = this.querySelector(\"html\")\n      if (!html) {\n        html = new VElement(\"html\")\n        this.appendChild(html)\n      }\n      head = new VElement(\"head\")\n      html.insertBefore(html)\n    }\n    return head\n  }\n}\n\nexport function createDocument(): VDocument {\n  return new VDocument()\n}\n\nexport function createHTMLDocument(): VHTMLDocument {\n  return new VHTMLDocument()\n}\n\nexport let document = createDocument()\nexport let h = hFactory({ document })\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { VDocumentFragment, VNodeQuery } from \"./vdom\"\n\nexport function removeBodyContainer(body: VNodeQuery): VNodeQuery {\n  let ehead = body.querySelector(\"head\")\n  let ebody = body.querySelector(\"body\")\n  if (ebody || ehead) {\n    let body = new VDocumentFragment()\n    ehead && body.appendChild(ehead.childNodes)\n    ebody && body.appendChild(ebody.children)\n    return body\n  }\n  return body\n}\n","// Taken from https://github.com/creeperyang/html-parser-lite\n// and slightly modified. Original also under MIT license. Thanks.\n\n// attribute, like href=\"javascript:void(0)\"\n// 1. start with name (not empty and not =)\n// 2. and then \\s*=\\s*\n// 3. and value can be \"value\" | 'value' | value\n// 4. 2 and 3 are optional\nconst attrRe = /([^=\\s]+)(\\s*=\\s*((\"([^\"]*)\")|('([^']*)')|[^>\\s]+))?/gm\nconst endTagRe = /^<\\/([^>\\s]+)[^>]*>/m\n// start tag, like <a href=\"link\"> <img/>\n// 1. must start with <tagName\n// 2. optional attrbutes\n// 3. /> or >\nconst startTagRe =\n  /^<([^>\\s\\/]+)((\\s+[^=>\\s]+(\\s*=\\s*((\"[^\"]*\")|('[^']*')|[^>\\s]+))?)*)\\s*\\/?\\s*>/m\nconst selfCloseTagRe = /\\s*\\/\\s*>\\s*$/m\n\n/**\n * This is a simple html parser. Will read and parse html string.\n *\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\nexport class HtmlParser {\n  scanner: any\n  options: any\n  attrRe = attrRe\n  endTagRe = endTagRe\n  startTagRe = startTagRe\n  defaults = { ignoreWhitespaceText: false }\n\n  constructor(options) {\n    options = options || {}\n    if (options.scanner) {\n      this.scanner = options.scanner\n      options.scanner = null\n    }\n    this.options = Object.assign({}, this.defaults, options)\n  }\n\n  parse(html: string) {\n    let treatAsChars = false\n    let index, match, characters\n    while (html.length) {\n      // comment\n      if (html.substring(0, 4) === \"<!--\") {\n        index = html.indexOf(\"-->\")\n        if (index !== -1) {\n          this.scanner.comment(html.substring(4, index))\n          html = html.substring(index + 3)\n          treatAsChars = false\n        } else {\n          treatAsChars = true\n        }\n      }\n      // end tag\n      else if (html.substring(0, 2) === \"</\") {\n        match = this.endTagRe.exec(html)\n        if (match) {\n          // @ts-ignore\n          html = RegExp.rightContext\n          treatAsChars = false\n          this.parseEndTag(RegExp.lastMatch, match[1])\n        } else {\n          treatAsChars = true\n        }\n      }\n      // start tag\n      else if (html.charAt(0) === \"<\") {\n        match = this.startTagRe.exec(html)\n        if (match) {\n          // @ts-ignore\n          html = RegExp.rightContext\n          treatAsChars = false\n          this.parseStartTag(RegExp.lastMatch, match[1], match)\n        } else {\n          treatAsChars = true\n        }\n      }\n\n      if (treatAsChars) {\n        index = html.indexOf(\"<\")\n\n        if (index === 0) {\n          // First char is a < so find the next one\n          index = html.substring(1).indexOf(\"<\")\n        }\n\n        if (index === -1) {\n          characters = html\n          html = \"\"\n        } else {\n          characters = html.substring(0, index)\n          html = html.substring(index)\n        }\n\n        if (!this.options.ignoreWhitespaceText || !/^\\s*$/.test(characters)) {\n          this.scanner.characters(characters)\n        }\n      }\n\n      treatAsChars = true\n      match = null\n    }\n  }\n\n  parseStartTag(input, tagName, match) {\n    const isSelfColse = selfCloseTagRe.test(input)\n    let attrInput = match[2]\n    if (isSelfColse) {\n      attrInput = attrInput.replace(/\\s*\\/\\s*$/, \"\")\n    }\n    const attrs = this.parseAttributes(tagName, attrInput)\n    this.scanner.startElement(tagName, attrs, isSelfColse, match[0])\n  }\n\n  parseEndTag(input, tagName: string) {\n    this.scanner.endElement(tagName)\n  }\n\n  parseAttributes(tagName, input) {\n    const attrs = {}\n    input.replace(\n      this.attrRe,\n      (attr, name, c2, value, c4, valueInQuote, c6, valueInSingleQuote) => {\n        attrs[name] = valueInSingleQuote ?? valueInQuote ?? value ?? true\n      }\n    )\n    return attrs\n  }\n}\n","// Copyright (c) 2020 Dirk Holtwick. All rights reserved. https://holtwick.de/copyright\n\nimport { unescapeHTML } from \"./encoding\"\nimport { SELF_CLOSING_TAGS } from \"./html\"\nimport { HtmlParser } from \"./htmlparser\"\nimport {\n  document,\n  VDocType,\n  VDocumentFragment,\n  VElement,\n  VHTMLDocument,\n  VNode,\n  VTextNode,\n} from \"./vdom\"\n\n// Makes sure we operate on VNodes\nexport function vdom(obj: VNode | Buffer | string | null = null): VNode {\n  if (obj instanceof VNode) {\n    return obj\n  }\n  if (obj instanceof Buffer) {\n    obj = obj.toString(\"utf-8\")\n  }\n  if (typeof obj === \"string\") {\n    return parseHTML(obj)\n  }\n  // console.warn('Cannot convert to VDOM:', obj)\n  return new VDocumentFragment()\n}\n\nexport function parseHTML(html: string): VDocumentFragment | VHTMLDocument {\n  if (typeof html !== \"string\") {\n    console.error(\"parseHTML requires string, found\", html)\n    throw new Error(\"parseHTML requires string\")\n  }\n\n  let frag =\n    html.indexOf(\"<!\") === 0 ? new VHTMLDocument(true) : new VDocumentFragment() // !hack\n\n  let stack: VNode[] = [frag]\n\n  let parser = new HtmlParser({\n    // the for methods must be implemented yourself\n    scanner: {\n      startElement(\n        tagName: string,\n        attrs: Record<string, string>,\n        isSelfClosing: boolean\n      ) {\n        const lowerTagName = tagName.toLowerCase()\n\n        if (lowerTagName === \"!doctype\") {\n          frag.docType = new VDocType()\n          return\n        }\n\n        for (let name in attrs) {\n          if (attrs.hasOwnProperty(name)) {\n            let value = attrs[name]\n            // console.log(name, value)\n            if (typeof value === \"string\") {\n              attrs[name] = unescapeHTML(value)\n            }\n          }\n        }\n        let parentNode = stack[stack.length - 1]\n        if (parentNode) {\n          const element = document.createElement(tagName, attrs)\n          parentNode.appendChild(element)\n          if (\n            !(\n              SELF_CLOSING_TAGS.includes(tagName.toLowerCase()) || isSelfClosing\n            )\n          ) {\n            stack.push(element)\n          }\n        }\n      },\n      endElement(tagName: string) {\n        stack.pop()\n      },\n      characters(text: string) {\n        text = unescapeHTML(text)\n        let parentNode = stack[stack.length - 1]\n        if (parentNode?.lastChild?.nodeType === VNode.TEXT_NODE) {\n          parentNode.lastChild._text += text\n        } else {\n          if (parentNode) {\n            parentNode.appendChild(new VTextNode(text))\n            // } else {\n            //   console.trace(parentNode, stack)\n          }\n        }\n      },\n      comment(text: string) {},\n    },\n  })\n  parser.parse(html)\n  // console.log(\"frag\", frag)\n  return frag\n}\n\n// export function parseHTML2(html) {\n//   let frag = new VDocumentFragment()\n//\n//   let stack = [frag]\n//   let currentElement = frag\n//\n//   let parser = new Parser({\n//     onopentag: (name, attrs) => {\n//       let element = document.createElement(name, attrs)\n//       stack.push(element)\n//       currentElement.appendChild(element)\n//       currentElement = element\n//     },\n//     ontext: function (text) {\n//       if (currentElement?.lastChild?.nodeType === VNode.TEXT_NODE) {\n//         currentElement.lastChild._text += text\n//       } else {\n//         currentElement.appendChild(new VTextNode(text))\n//       }\n//     },\n//     onclosetag: function (name) {\n//       let element = stack.pop()\n//       currentElement = stack[stack.length - 1]\n//       // if (element.nodeName !== currentElement.nodeName) {\n//       //   console.log('error', element, currentElement)\n//       // }\n//     },\n//   }, { decodeEntities: true })\n//   parser.write(html)\n//   parser.end()\n//\n//   // console.log('frag', frag.innerHTML)\n//\n//   return frag\n// }\n\nVElement.prototype.setInnerHTML = function (html) {\n  let frag = parseHTML(html)\n  this._childNodes = frag._childNodes\n  this._fixChildNodesParent()\n}\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { VDocument, VNode, VTextNode } from \"./vdom\"\n\nconst SELECTOR_BLOCK_ELEMENTS =\n  \"meta,link,script,p,h1,h2,h3,h4,h5,h6,blockquote,div,ul,ol,li,article,section,footer,head,body,title,nav,section,article,hr,form\"\nconst TAGS_KEEP_CONTENT = [\"PRE\", \"CODE\", \"SCRIPT\", \"STYLE\", \"TT\"]\n\nfunction level(element: VNode): string {\n  let indent = \"\"\n  while (element.parentNode) {\n    indent += \"  \"\n    element = element.parentNode\n  }\n  return indent.substr(2)\n}\n\nexport function tidyDOM(document: VDocument) {\n  document.handle(SELECTOR_BLOCK_ELEMENTS, (e) => {\n    // Ignore if inside PRE etc.\n    let ee = e\n    while (ee) {\n      if (TAGS_KEEP_CONTENT.includes(ee.tagName)) return\n      ee = ee.parentNode\n    }\n\n    let prev = e.previousSibling\n    if (\n      !prev ||\n      prev.nodeType !== VNode.TEXT_NODE ||\n      !prev.nodeValue?.endsWith(\"\\n\")\n    ) {\n      e.parentNode?.insertBefore(new VTextNode(\"\\n\"), e)\n    }\n    e.parentNode?.insertBefore(new VTextNode(level(e)), e)\n\n    let next = e.nextSibling\n    if (\n      !next ||\n      next.nodeType !== VNode.TEXT_NODE ||\n      !next.nodeValue?.startsWith(\"\\n\")\n    ) {\n      if (next) {\n        e.parentNode?.insertBefore(new VTextNode(\"\\n\"), next)\n      } else {\n        e.parentNode?.appendChild(new VTextNode(\"\\n\"))\n      }\n    }\n\n    if (e.childNodes.length) {\n      let first = e.firstChild\n      if (first.nodeType === VNode.TEXT_NODE) {\n        e.insertBefore(new VTextNode(\"\\n\" + level(e) + \"  \"))\n      }\n      e.appendChild(new VTextNode(\"\\n\" + level(e)))\n    }\n  })\n}\n","// (C)opyright 2021-07-20 Dirk Holtwick, holtwick.it. All rights reserved.\n\nimport { hArgumentParser } from \"./h\"\nimport { markup } from \"./html\"\n\nexport function xml(itag: string, iattrs?: object, ...ichildren: any[]) {\n  let { tag, attrs, children } = hArgumentParser(itag, iattrs, ichildren)\n  return markup(true, tag, attrs, children)\n}\n\n// export const xmlVDOM = markup.bind(null, true)\n\nxml.firstLine = '<?xml version=\"1.0\" encoding=\"utf-8\"?>'\nxml.xml = true\n\nexport let h = xml\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}